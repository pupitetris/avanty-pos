<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.1-alpha" author="Arturo Espinosa" last-position="0,0" last-zoom="0.95"
	 default-schema="av" default-owner="postgres">
<role name="avanty"
      login="true"
      encrypted="true"
      password="123">
	<comment><![CDATA[Low-security user for operation of the avanty system.]]></comment>
	<appended-sql><![CDATA[ALTER USER avanty SET search_path TO av,public;]]></appended-sql>
</role>

<database name="avanty" encoding="UTF8" template="template0" lc-collate="Spanish_Mexico" lc-ctype="Spanish_Mexico" append-at-eod="true">
	<appended-sql><![CDATA[ALTER DATABASE avanty SET search_path TO av,public;

GRANT USAGE ON SEQUENCE av.account_user_id_seq TO avanty;
GRANT USAGE ON SEQUENCE av.ticket_ticket_id_seq TO avanty;
]]></appended-sql>
</database>

<schema name="public" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="av" fill-color="#e1e1e1">
	<role name="avanty"/>
</schema>

<domain name="uid" constraint="uid_check" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Special type for user id's to be automatically recognized by the rpc system.]]></comment>
		<type name="smallint" length="0"/>
	<expression><![CDATA[VALUE >= 1 AND VALUE < 32768]]></expression>
</domain>

<domain name="ts" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[just a short name for " timestamp with time zone"]]></comment>
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
</domain>

<schema name="pgcrypto" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
	<comment><![CDATA[Separate schema for all cryptographic functions to avoid pollution.]]></comment>
</schema>

<extension name="pgcrypto">
	<schema name="pgcrypto"/>
	<comment><![CDATA[Cryptographic routines.]]></comment>
</extension>

<table name="user_cashier" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type cashier.]]></comment>
	<position x="640" y="1300"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="user_cashier_pk" index="0"/>
	</customidxs>
</table>

<usertype name="charp_account_status" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="active,disabled,deleted"/>
</usertype>

<usertype name="charp_error_code" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="USERUNK,USERDIS,PROCUNK,REQUNK,REPFAIL,ASSERT,USERPARMPERM,USERPERM,MAILFAIL,DATADUP,NOTFOUND,EXIT,SUCCESS"/>
</usertype>

<table name="user_supervisor" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type supervisor.]]></comment>
	<position x="640" y="1360"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="user_supervisor_pk" index="0"/>
	</customidxs>
</table>

<table name="account" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[user accounts]]></comment>
	<position x="40" y="1180"/>
	<column name="user_id" not-null="true">
		<type name="smallserial" length="0"/>
		<comment><![CDATA[Independent ID for users, to allow for login name changes.]]></comment>
	</column>
	<column name="creator_user_id">
		<type name="smallint" length="0"/>
		<comment><![CDATA[uid of the user that created this user.]]></comment>
	</column>
	<column name="login" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Handle specified by the user for credentials.]]></comment>
	</column>
	<column name="salt" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Random per-user salt to make password hash cracking difficult.]]></comment>
	</column>
	<column name="password" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Salted sha512 hash of user-provided password.]]></comment>
	</column>
	<column name="password_expiration">
		<type name="av.ts" length="0" with-timezone="true"/>
		<comment><![CDATA[Forces the user to set a new password upon login if the timestamp has expired.]]></comment>
	</column>
	<column name="status" not-null="true">
		<type name="av.charp_account_status" length="0"/>
		<comment><![CDATA[only active users may run requests to the server]]></comment>
	</column>
	<column name="is_first" not-null="true" default-value="TRUE">
		<type name="boolean" length="0"/>
		<comment><![CDATA[true if the user has never opened session.]]></comment>
	</column>
	<column name="created" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Time of creation.]]></comment>
	</column>
	<constraint name="account_pk" type="pk-constr" table="av.account">
		<columns names="user_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="check_account_login" type="ck-constr" table="av.account">
			<expression><![CDATA[login ~ '^[a-zA-Z0-9_.áéíóúñÁÉÚÍÓÚÑüÜ]+$']]></expression>
		<comment><![CDATA[Restrictions to the login string.]]></comment>
	</constraint>
	<constraint name="check_account_login_unique" type="uq-constr" table="av.account">
		<columns names="login" ref-type="src-columns"/>
		<comment><![CDATA[Two users can't have the same login.]]></comment>
	</constraint>
</table>

<table name="user_maintenance" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type maintenance.]]></comment>
	<position x="640" y="1420"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="0"/>
		<object name="user_maintenance_pk" index="1"/>
	</customidxs>
</table>

<relationship name="user_maintenance_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_maintenance"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<relationship name="user_cashier_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_cashier"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<usertype name="user_activity_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[other activities may be added later]]></comment>
	<enumeration values="login,logout,shift_begin,shift_end,charge_check"/>
</usertype>

<table name="user_activity">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[logs login/logout actions from the users for the user report for the supervisor]]></comment>
	<position x="600" y="1180"/>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[when the activity occurred]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="av.user_activity_type" length="0"/>
	</column>
	<column name="detail">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[additional key/values for future flexibility]]></comment>
	</column>
	<constraint name="user_activity_pk" type="pk-constr" table="av.user_activity">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="terminal_id" index="2"/>
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="terminal_fk" index="2"/>
	</customidxs>
</table>

<relationship name="account_has_many_user_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_activity"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<table name="supervisor_challenge">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[We are keeping a registry of all challenges, for security audits.]]></comment>
	<position x="1080" y="1460"/>
	<column name="string" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[A random-generated string that the supervisor must give to support.]]></comment>
	</column>
	<column name="expiration">
		<type name="av.ts" length="0"/>
	</column>
	<column name="solution">
		<type name="varchar" length="0"/>
		<comment><![CDATA[The solution that was provided by support. A correct solution will activate the system.]]></comment>
	</column>
	<constraint name="supervisor_challenge_pk" type="pk-constr" table="av.supervisor_challenge">
		<columns names="string" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="user_supervisor_fk" index="1"/>
	</customidxs>
</table>

<usertype name="terminal_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="user_pos,boom_entry,boom_exit,tvm"/>
</usertype>

<table name="terminal">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="20" y="780"/>
	<column name="terminal_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="term_type" not-null="true">
		<type name="av.terminal_type" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[what to show on the UI]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[IP Address that identifies this terminal]]></comment>
	</column>
	<column name="qz_private_key">
		<type name="text" length="0"/>
		<comment><![CDATA[Private RSA key for qz-tray request signing.]]></comment>
	</column>
	<column name="qz_certificate">
		<type name="text" length="0"/>
		<comment><![CDATA[OpenSSL certificate to grant connection to the qz-tray server.]]></comment>
	</column>
	<constraint name="terminal_pk" type="pk-constr" table="av.terminal">
		<columns names="terminal_id" ref-type="src-columns"/>
	</constraint>
</table>

<relationship name="terminal_has_many_user_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.terminal"
	 dst-table="av.user_activity"
	 src-required="true" dst-required="false"/>

<usertype name="ticket_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="entry,exit,rent,deposit,withdrawal,lost"/>
</usertype>

<table name="ticket">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[a printed ticket]]></comment>
	<position x="980" y="120"/>
	<column name="ticket_id" not-null="true">
		<type name="serial" length="0"/>
		<comment><![CDATA[Only the last digit is used in the printout.]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.ticket_type" length="0"/>
	</column>
	<column name="detail">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[Documenting data with details printed on the ticket.]]></comment>
	</column>
	<constraint name="ticket_pk" type="pk-constr" table="av.ticket">
		<columns names="ticket_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="terminal_id" index="1"/>
		<object name="user_id" index="2"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="2"/>
		<object name="terminal_fk" index="1"/>
	</customidxs>
</table>

<relationship name="terminal_has_many_ticket" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.terminal"
	 dst-table="av.ticket"
	 src-required="true" dst-required="false"/>

<usertype name="rate_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="regular,lost,rent"/>
</usertype>

<table name="rate">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="980" y="720"/>
	<column name="rate_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.rate_type" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[For UI purposes, for the rate selector.]]></comment>
	</column>
	<column name="script" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[a DSL to be executed to itemize the payment and generate a total.]]></comment>
	</column>
	<column name="description">
		<type name="varchar" length="0"/>
		<comment><![CDATA[documentation]]></comment>
	</column>
	<constraint name="rate_pk" type="pk-constr" table="av.rate">
		<columns names="rate_id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="payment_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Payment methods]]></comment>
	<enumeration values="tender,credit_card,debit_card"/>
</usertype>

<table name="movement">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="1400" y="320"/>
	<column name="timestamp" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="method" not-null="true">
		<type name="av.payment_type" length="0"/>
	</column>
	<column name="amount" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[in cents]]></comment>
	</column>
	<column name="change">
		<type name="integer" length="0"/>
		<comment><![CDATA[in cents. May be null if does not apply for payment method.]]></comment>
	</column>
	<column name="reference">
		<type name="varchar" length="0"/>
		<comment><![CDATA[For electrnoic payments, a reference string to conciliate accounting.]]></comment>
	</column>

	<customidxs object-type="column">
		<object name="rate_id" index="2"/>
		<object name="ticket_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_pk" index="1"/>
		<object name="rate_fk" index="0"/>
		<object name="ticket_fk" index="2"/>
	</customidxs>
</table>

<relationship name="rate_has_many_payment" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.movement"
	 src-required="false" dst-required="false"/>

<usertype name="tender_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="coin,bill"/>
</usertype>

<table name="tender">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[catalog, describes a coin or a bill]]></comment>
	<position x="1400" y="520"/>
	<column name="tender_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="denomination" not-null="true">
		<type name="smallint" length="0"/>
		<comment><![CDATA[in cents]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="av.tender_type" length="0"/>
	</column>
	<constraint name="tender_pk" type="pk-constr" table="av.tender">
		<columns names="tender_id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="exchange_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="received,change"/>
</usertype>

<table name="tender_exchange">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="1800" y="400"/>
	<column name="type" not-null="true">
		<type name="av.exchange_type" length="0"/>
	</column>
	<column name="count" not-null="true">
		<type name="smallint" length="0"/>
		<comment><![CDATA[how many of this bill or coin]]></comment>
	</column>

	<customidxs object-type="column">
		<object name="tender_id" index="1"/>
		<object name="ticket_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_fk" index="2"/>
		<object name="tender_exchange_pk" index="0"/>
		<object name="tender_fk" index="1"/>
	</customidxs>
</table>

<relationship name="tender_has_many_tender_exchange" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.tender"
	 dst-table="av.tender_exchange"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<table name="owner">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[A person or company owning a vehicle]]></comment>
	<position x="2140" y="20"/>
	<column name="owner_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="address">
		<type name="varchar" length="0"/>
		<comment><![CDATA[all of the address, as an open field]]></comment>
	</column>
	<column name="fiscal_code">
		<type name="varchar" length="0"/>
	</column>
	<column name="fiscal_address">
		<type name="varchar" length="0"/>
		<comment><![CDATA[open field]]></comment>
	</column>
	<column name="phone">
		<type name="varchar" length="0"/>
	</column>
	<constraint name="owner_pk" type="pk-constr" table="av.owner">
		<columns names="owner_id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="vehicle_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="motorcycle,compact,regular,light_truck,truck,special"/>
</usertype>

<table name="vehicle">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="2580" y="80"/>
	<column name="vehicle_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="plate" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.vehicle_type" length="0"/>
	</column>
	<column name="make" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="model" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="year" not-null="true">
		<type name="smallint" length="0"/>
	</column>
	<column name="color" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<constraint name="vehicle_pk" type="pk-constr" table="av.vehicle">
		<columns names="vehicle_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="owner_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="owner_fk" index="1"/>
	</customidxs>
</table>

<relationship name="owner_has_many_vehicle" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.owner"
	 dst-table="av.vehicle"
	 src-required="true" dst-required="false"/>

<table name="rent">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[a car pension]]></comment>
	<position x="3000" y="220"/>
	<column name="rent_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="expiration" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="is_cancelled" not-null="true">
		<type name="boolean" length="0"/>
	</column>
	<column name="card_number">
		<type name="varchar" length="0"/>
		<comment><![CDATA[ID of the contactless card]]></comment>
	</column>
	<column name="last_in">
		<type name="av.ts" length="0"/>
	</column>
	<column name="last_out">
		<type name="av.ts" length="0"/>
	</column>
	<constraint name="rent_pk" type="pk-constr" table="av.rent">
		<columns names="rent_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rate_id" index="3"/>
		<object name="ticket_id" index="2"/>
		<object name="vehicle_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="rate_fk" index="4"/>
		<object name="rent_uq" index="2"/>
		<object name="ticket_fk" index="1"/>
		<object name="vehicle_fk" index="3"/>
	</customidxs>
</table>

<relationship name="rent_has_one_ticket" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.ticket"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"/>

<relationship name="vehicle_has_many_rent" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.vehicle"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"/>

<relationship name="rate_has_many_rent" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"/>

<usertype name="rent_operation_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="new,edit,renew,expired,cancelled,reactivated,rate_change"/>
</usertype>

<table name="rent_operation">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[history of operations regarding a rent account]]></comment>
	<position x="3480" y="460"/>
	<column name="timestamp" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.rent_operation_type" length="0"/>
	</column>
	<constraint name="rent_operation_pk" type="pk-constr" table="av.rent_operation">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rate_id" index="2"/>
		<object name="rent_id" index="0"/>
		<object name="ticket_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_fk" index="3"/>
		<object name="rate_fk" index="2"/>
		<object name="rent_fk" index="1"/>
		<object name="rent_operation_uq" index="4"/>
	</customidxs>
</table>

<relationship name="rent_has_many_rent_operation" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.rent"
	 dst-table="av.rent_operation"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<relationship name="rate_has_many_rent_operation" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.rent_operation"
	 src-required="true" dst-required="false"/>

<usertype name="rent_activity_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="in,out"/>
</usertype>

<table name="rent_activity">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[when a vehicle in rented parking left or came into the lot]]></comment>
	<position x="3480" y="280"/>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.rent_activity_type" length="0"/>
	</column>
	<constraint name="rent_activity_pk" type="pk-constr" table="av.rent_activity">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rent_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="rent_fk" index="1"/>
	</customidxs>
</table>

<relationship name="rent_has_many_rent_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.rent"
	 dst-table="av.rent_activity"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<table name="cashier_shift">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[who is logged in in what terminal]]></comment>
	<position x="1080" y="1120"/>
	<column name="last_event" not-null="true">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[TS of last interactive event, to avoid insertion of events (tickets, movements) with arbitrary dates]]></comment>
	</column>

	<customidxs object-type="column">
		<object name="terminal_id" index="0"/>
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="cashier_shift_pk" index="0"/>
		<object name="cashier_shift_uq" index="3"/>
		<object name="terminal_fk" index="1"/>
		<object name="user_cashier_fk" index="2"/>
	</customidxs>
</table>

<relationship name="terminal_account_has_one_terminal" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.terminal"
	 dst-table="av.cashier_shift"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<table name="request">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[RPC requests being currently handled by CHARP (Challenge-Authenticated Remote Procedures)]]></comment>
	<appended-sql><![CDATA[GRANT USAGE ON SEQUENCE request_request_id_seq TO avanty;]]></appended-sql>
	<position x="600" y="1580"/>
	<column name="request_id" not-null="true">
		<type name="serial" length="0"/>
		<comment><![CDATA[id of this request currently being processed. will be copied to request_log as soon as its life has ended.]]></comment>
	</column>
	<column name="random_bytes" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[hex representation of random bytes sent to client as a challenge.]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Stamp of when the request started. Requests that are too old will be removed by pgAgent.]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[originating public IP Address, as reported by the web server.]]></comment>
	</column>
	<column name="proname" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[name of the stored procedure that was requested]]></comment>
	</column>
	<column name="params" not-null="true">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[parameters to the request stored procedure execution]]></comment>
	</column>
	<constraint name="request_pk" type="pk-constr" table="av.request">
		<columns names="request_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
	</customidxs>
</table>

<relationship name="account_has_many_request" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.request"
	 src-required="false" dst-required="false"/>

<usertype name="charp_request_status" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[CHARP request, logs how a request finished]]></comment>
	<enumeration values="success,exception,timeout"/>
</usertype>

<table name="request_log">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[CHARP requests log, for auditing]]></comment>
	<position x="580" y="1720"/>
	<column name="request_log_id" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[this is copied from request table but can't be FK because it will be deleted from request]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Stamp of when the request started. Requests that are too old will be removed by pgAgent.]]></comment>
	</column>
	<column name="error_code" not-null="true">
		<type name="av.charp_error_code" length="0"/>
		<comment><![CDATA[Use SUCCESS if no error was produced.]]></comment>
	</column>
	<column name="login" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[The username that was used during the request.]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[originating public IP Address, as reported by the web server.]]></comment>
	</column>
	<column name="proname" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[name of the stored procedure that was requested]]></comment>
	</column>
	<column name="params">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[parameters to the request stored procedure execution]]></comment>
	</column>
	<column name="err_params">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[The parameters that came from the raised exception.]]></comment>
	</column>
	<column name="finished" not-null="true">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[When the request was added to the log (either if it succeeded, was error, or time out)]]></comment>
	</column>
	<column name="status" not-null="true">
		<type name="av.charp_request_status" length="0"/>
		<comment><![CDATA[under what circumstances the request was logged]]></comment>
	</column>
	<constraint name="request_pk_1" type="pk-constr" table="av.request_log">
		<columns names="request_log_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
	</customidxs>
</table>

<relationship name="account_has_many_request_log" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.request_log"
	 src-required="false" dst-required="false"/>

<relationship name="user_supervisor_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_supervisor"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<index name="user_login_uniq" table="av.account"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[logins must be unique.]]></comment>
		<idxelement use-sorting="false">
			<column name="login"/>
		</idxelement>
</index>

<usertype name="charp_param_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[parameters that can be mapped by the CHARP RPC system.]]></comment>
	<enumeration values="UID,INT,STR,BOOL,DATE,INTARR,STRARR,BOOLARR,REMOTE_ADDR,TS"/>
</usertype>

<usertype name="charp_cmd_code" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[commands that the DB can send to the web gateway through the notification system]]></comment>
	<enumeration values="FILE_CREATE,FILE_DELETE,FILE_MOVE,FILE_COPY,EXIT,OTHER"/>
</usertype>

<relationship name="payment_has_one_ticket" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.ticket"
	 dst-table="av.movement"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<relationship name="payment_has_many_tender_exchange" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.movement"
	 dst-table="av.tender_exchange"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<relationship name="rent_operation_has_one_payment" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.movement"
	 dst-table="av.rent_operation"
	 src-required="false" dst-required="false"/>

<schema name="rp" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
	<comment><![CDATA[Stored procedures that can be called from the CHARP gateway.]]></comment>
</schema>

<function name="charp_log_error"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Send an error report to the request log, optionally (based on request_id) moving data from av.request to log the lifecycle of a given request.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_request_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_code">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_proname">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_err_params">
		<type name="jsonb" length="0"/>
	</parameter>
	<parameter name="_status">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id account.user_id%TYPE;
BEGIN
	IF _login IS NOT NULL THEN
		SELECT user_id INTO _user_id FROM account WHERE login = _login;
	END IF;

	IF _request_id IS NULL THEN
		_request_id := nextval('request_request_id_seq');
		INSERT INTO request_log
			VALUES(_request_id, _user_id, CURRENT_TIMESTAMP, _code::charp_error_code,
				_login, _ip_addr, _proname, NULL, _err_params,
				CURRENT_TIMESTAMP, _status::charp_request_status);
	ELSE
		INSERT INTO request_log
			SELECT r.request_id, r.user_id, r.timestamp, _code::charp_error_code, 
				_login, r.ip_addr, r.proname, r.params, _err_params, 
				CURRENT_TIMESTAMP, _status::charp_request_status
				FROM request AS r WHERE r.request_id = _request_id;
		DELETE FROM request WHERE request_id = _request_id;
	END IF;
END]]></definition>
</function>

<function name="charp_raise"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Raise and log an exception with the CHARP format for client consumption. WARNING: exceptions cause all data changes to be rolled back! Use charp_cmd to avoid rollbacks.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_code">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_args" variadic="true" default-value="ARRAY[]::text[]">
		<type name="varchar" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_i integer;
	_sqlcode text;
	_code_t charp_error_code;
BEGIN
	IF substring(_code FROM 1 FOR 1) = '-' THEN
	   _code_t := substring(_code FROM 2);
	ELSE
	   _code_t := _code;
	END IF;

	SELECT INTO _sqlcode
	       CASE _code_t
		    WHEN 'USERUNK'      THEN 'RP001'
			WHEN 'USERDIS'      THEN 'RP002'
		    WHEN 'PROCUNK'      THEN 'RP003'
		    WHEN 'REQUNK'       THEN 'RP004'
		    WHEN 'REPFAIL'      THEN 'RP005'
		    WHEN 'ASSERT'       THEN 'RP006'
		    WHEN 'USERPARMPERM' THEN 'RP007'
		    WHEN 'USERPERM'     THEN 'RP008'
		    WHEN 'MAILFAIL'     THEN 'RP009'
		    WHEN 'DATADUP'      THEN 'RP010'
		    WHEN 'NOTFOUND'     THEN 'RP011'
		    WHEN 'EXIT'         THEN 'RP012'
		    ELSE 'RP000'
	       END;

	RAISE EXCEPTION '|>%|%|', _code, array_to_json(_args) USING ERRCODE = _sqlcode;
END;]]></definition>
</function>

<function name="charp_cmd"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Send a command to the CHARP CGI layer. Unlike charp_raise, this won't create an exception that will rollback the current transaction.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_cmd">
		<type name="av.charp_cmd_code" length="0"/>
	</parameter>
	<parameter name="_args" variadic="true" default-value="ARRAY[]::text[]">
		<type name="text" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_i integer;
BEGIN
	RAISE INFO '|>%|{%}|', _cmd::text, array_to_json(_args);
END;]]></definition>
</function>

<function name="charp_rp_get_function_by_name"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Find given function within rp schema, raise PROCUNK if not found.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_name varchar;
BEGIN
	SELECT proname INTO _name 
		FROM pg_proc AS p 
			JOIN pg_namespace AS ns
				ON (p.pronamespace = ns.oid)
		WHERE p.proname = _function_name AND ns.nspname = 'rp';
	IF NOT FOUND THEN
	   PERFORM charp_raise('PROCUNK', _function_name);
	END IF;
	RETURN _name;
END;]]></definition>
</function>

<function name="charp_request_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Registers a request returning a corresponding challlenge for the client to respond.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_params">
		<type name="jsonb" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_random_bytes character varying;
BEGIN
	_random_bytes := encode(pgcrypto.gen_random_bytes(32), 'hex');
	INSERT INTO request VALUES(
		DEFAULT,
		charp_account_get_id_by_login_status(_login, 'active'),
		_random_bytes, 
		CURRENT_TIMESTAMP,
		_ip_addr,
		charp_rp_get_function_by_name(_function_name),
		_params
	);
	RETURN _random_bytes;
END;]]></definition>
</function>

<function name="charp_get_function_params"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Convert the parameter array of a function for given oids to charp_param_type.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="av.charp_param_type" length="0" dimension="1"/>
	</return-type>
	<parameter name="_proargtypes">
		<type name="oidvector" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_fparams charp_param_type ARRAY;
BEGIN
	SELECT ARRAY( 
	       	      SELECT 
			     CASE format_type (_proargtypes[s.i], NULL)
				  WHEN 'uid'	   		 	 THEN 'UID'
				  WHEN 'integer'		     THEN 'INT'
				  WHEN 'character varying'   THEN 'STR'
				  WHEN 'text'			     THEN 'STR'
				  WHEN 'boolean'		     THEN 'BOOL'
				  WHEN 'date'			     THEN 'DATE'
				  WHEN 'ts'			         THEN 'TS'
				  WHEN 'timestamp'	         THEN 'TS'
				  WHEN 'timestamp with time zone' THEN 'TS'
				  WHEN 'integer[]'		     THEN 'INTARR'
				  WHEN 'character varying[]' THEN 'STRARR'
				  WHEN 'text[]'			     THEN 'STRARR'
				  WHEN 'boolean[]'			 THEN 'BOOLARR'
				  WHEN 'remote_addr'		 THEN 'REMOTE_ADDR'
				  ELSE 'STR'
			     END
			     FROM generate_series(0, array_upper(_proargtypes, 1)) AS s(i)
		      ) 
	       INTO _fparams;
	RETURN _fparams;
END;]]></definition>
</function>

<function name="charp_function_params"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Return the input parameter types that a given stored procedure requires.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="av.charp_param_type" length="0" dimension="1"/>
	</return-type>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_fparams charp_param_type ARRAY;
BEGIN
	SELECT charp_get_function_params (p.proargtypes) INTO _fparams 
		FROM pg_proc AS p 
			JOIN pg_namespace AS ns
				ON (p.pronamespace = ns.oid)
		WHERE p.proname = _function_name AND ns.nspname = 'rp';
	IF NOT FOUND THEN
	   PERFORM charp_raise('PROCUNK', _function_name);
	END IF;
	RETURN _fparams;
END;]]></definition>
</function>

<function name="charp_request_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that a given request is registered with the given data and compare the hash with one locally computed. Return the necessary data to execute.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="request_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="fname">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="fparams">
		<type name="av.charp_param_type" length="0" dimension="1"/>
	</parameter>
	<parameter name="req_params">
		<type name="jsonb" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_hash">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_req RECORD;
	_our_hash varchar;
	_status av.charp_request_status;
BEGIN
	SELECT 
	       r.request_id AS request_id,
	       a.user_id AS user_id,
	       p.proname AS proname, 
	       r.params AS params, 
	       charp_get_function_params (p.proargtypes) AS fparams, 
	       a.password AS password
	       INTO _req
	       FROM request AS r 
	       		NATURAL JOIN account AS a 
	       		NATURAL JOIN pg_proc AS p
	       		JOIN pg_namespace AS ns ON (p.pronamespace = ns.oid)
	       WHERE a.login = _login 
			 AND r.random_bytes = _chal
			 AND r.ip_addr = _ip_addr
			 AND ns.nspname = 'rp';

	IF _req IS NULL THEN
		PERFORM charp_raise('REQUNK', _username, _ip_addr::text, _chal);
	END IF;

	_our_hash := encode(pgcrypto.digest(_login || _chal || _req.password, 'sha256'), 'hex');
	IF _our_hash <> _hash THEN
		PERFORM charp_raise('REPFAIL', _login, _ip_addr::text, _chal, _req.request_id::text);
	END IF;

	request_id := _req.request_id;
	user_id := _req.user_id;
	fname := _req.proname;
	req_params := _req.params;
	fparams := _req.fparams;
	RETURN NEXT;
END;]]></definition>
</function>

<function name="check_url"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that an entrypoint URL was created by the system.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<parameter name="_url">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_hash_pos integer;
	_url_part text;
	_hash_part text;
	_our_hash text;
BEGIN
	_hash_pos := position ('#' IN _url);
	IF _hash_pos < 1 THEN
	   PERFORM charp_raise('ASSERT', 'URL has #');
	END IF;
	
	_url_part := substring (_url FROM 1 FOR _hash_pos - 1);
	_hash_part := substring (_url FROM _hash_pos + 1);
	_our_hash := rp_sign_url(_url_part);

	IF _our_hash = _hash_part THEN
	   RETURN TRUE;
	END IF;
	RETURN FALSE;
END;]]></definition>
</function>

<function name="sign_url"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Generate a signature for a given URL. FIXME: define url_check_hash1 and hash2]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_url">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT encode(digest('M4_DEFN(url_check_hash1)' || _url
	|| 'M4_DEFN(url_check_hash2)', 'sha256'), 'hex')]]></definition>
</function>

<function name="user_auth"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Trivially return TRUE. If the user was authenticated, everything went OK with challenge-request sequence and there is nothing left to do: success.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT TRUE]]></definition>
</function>

<function name="user_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Create a basic user with no user class. Account is activated by default. Returns the new user_id.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="smallint" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password_expiration" default-value="NULL">
		<type name="av.ts" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
	_user_id account.user_id%TYPE;
BEGIN
	_salt := pgcrypto.gen_salt('bf', 8);
	INSERT INTO account
		VALUES(DEFAULT, _uid, _login, _salt, 
			pgcrypto.crypt(_plain_password, _salt), 
			_password_expiration, 'active', TRUE, CURRENT_TIMESTAMP) 
		RETURNING user_id INTO _user_id;
	RETURN _user_id;
END;]]></definition>
</function>

<function name="anon_salt_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the salt for the given user so it can be used as a base to generate the encrypted hash of the password client-side, and challenges can be signed using the exact same secrets on both sides.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
BEGIN
	SELECT salt INTO _salt FROM account WHERE login = _login;
	IF NOT FOUND THEN
		PERFORM charp_raise ('USERUNK');
	END IF;

	RETURN _salt;
END;]]></definition>
</function>

<function name="charp_account_get_id_by_login_status"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the user id for a given user name and status, raise USERUNK if not found. NULL status matches any status.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_status">
		<type name="av.charp_account_status" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_id av.account.user_id%TYPE;
	_user_status av.account.status%TYPE;
BEGIN
	SELECT a.user_id, a.status INTO _id, _user_status FROM account AS a
	       WHERE a.login = _login;

	IF NOT FOUND THEN
	   PERFORM charp_raise('USERUNK', _login::text, _status::text);
	END IF;

	IF _status IS NULL OR _status = _user_status THEN
		RETURN _id;
	END IF;

	IF _user_status = 'disabled' THEN
	   PERFORM charp_raise('-USERDIS', _login::text);
	END IF;

	-- user_status is deleted, probably.
	PERFORM charp_raise('USERUNK', _login::text, _status::text);
END;]]></definition>
</function>

<function name="anon_system_is_activated"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[check if the system has already been activated: you need a non-first supervisor account and a correctly signed challenge.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT COUNT(*) > 0 FROM supervisor_challenge 
	WHERE user_id = 1::uid 
		AND (expiration IS NULL OR expiration > CURRENT_TIMESTAMP)
		AND activation_solve_challenge (string) = solution;]]></definition>
</function>

<function name="activation_solve_challenge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Compute the numerical solution for a given challenge.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_challenge">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT array_to_string (
	ARRAY (
		SELECT ascii(q.ch) % 10 
			FROM (
                SELECT unnest (
					regexp_split_to_array (
						substring (
							pgcrypto.crypt (_challenge, '$2a$08$PqR7X.YexgDCsypnT0dFM.'),
							'.{8}$'
                        ), 
					'')
				) AS ch
			) AS q	
		), 
	'')]]></definition>
</function>

<function name="anon_activation_challenge_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[get the activation challenge, which may be generated if none is available.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[DECLARE
	_string av.supervisor_challenge.string%TYPE;
BEGIN
	SELECT string INTO _string
		FROM supervisor_challenge 
		WHERE user_id = 1::uid
			AND (expiration IS NULL OR expiration > CURRENT_TIMESTAMP)
			AND solution IS NULL;

	IF NOT FOUND THEN
		INSERT INTO supervisor_challenge 
			VALUES (activation_challenge_gen (), 1::uid, CURRENT_TIMESTAMP + '15 minutes', NULL)
			RETURNING string INTO _string;
	END IF;

	RETURN _string;
END;]]></definition>
</function>

<function name="activation_challenge_gen"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Generate a random string of digits to be solved by the provider's support]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT 
	SUBSTRING (
		regexp_replace (encode (pgcrypto.gen_random_bytes(64), 'hex'), '[a-f]', '', 'g')
	FROM 1 FOR 8)]]></definition>
</function>

<relationship name="user_supervisor_has_many_supervisor_challenge" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.user_supervisor"
	 dst-table="av.supervisor_challenge"
	 src-required="false" dst-required="false"/>

<function name="anon_activation_challenge_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Now check if the given challenge/solution pair is correct.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_solution">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_old_chal av.supervisor_challenge.string%TYPE;
BEGIN
	_old_chal := rp.anon_activation_challenge_get();

	IF _old_chal <> _chal THEN
		PERFORM charp_raise ('NOTFOUND');
	END IF;

	IF _solution IS NULL OR _solution <> activation_solve_challenge (_chal) THEN
		PERFORM charp_raise ('EXIT', 'BAD_SOLUTION');
	END IF;

	UPDATE supervisor_challenge 
		SET solution = _solution, expiration = NULL
		WHERE string = _chal AND user_id = 1::uid;

	RETURN TRUE;
END;]]></definition>
</function>

<domain name="remote_addr" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Used as parameter to RPs, maps at CHARP level to the address of the web client.]]></comment>
		<type name="inet" length="0"/>
</domain>

<function name="anon_supervisor_created"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the system requires an operations supervisor to be created.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT COUNT(*) > 0 FROM user_supervisor WHERE user_id <> 1;]]></definition>
</function>

<function name="user_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Create an user (only for supervisors).]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_role">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_new_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM user_supervisor_assert(_uid);

	_new_user_id := user_create (_uid, _login, _password, NULL);
	PERFORM user_role_add (_new_user_id, _role);
END;]]></definition>
</function>

<function name="user_role_add"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Set user as part of the given role. Do nothing if it already belongs to given role.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_role">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	CASE _role
		WHEN 'supervisor' THEN
			INSERT INTO user_supervisor VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		WHEN 'cashier' THEN
			INSERT INTO user_cashier VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		WHEN 'maintenance' THEN
			INSERT INTO user_maintenance VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		ELSE
			PERFORM charp_raise ('ASSERT', '_role NOT FOUND');
	END CASE;
END;]]></definition>
</function>

<function name="this_user_types_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the types this user is in.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<parameter name="cashier">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="supervisor">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="maintenance">
		<type name="boolean" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT c.user_id IS NOT NULL as cashier,
	s.user_id IS NOT NULL as supervisor,
    m.user_id IS NOT NULL as maintenance
    FROM account AS a 
    	NATURAL LEFT JOIN user_cashier AS c
    	NATURAL LEFT JOIN user_supervisor AS s 
    	NATURAL LEFT JOIN user_maintenance AS m
        WHERE a.user_id = _uid;]]></definition>
</function>

<function name="this_user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change the password of the calling user. Return the new salt.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	RETURN av.user_password_change (_uid, _plain_password);
END;]]></definition>
</function>

<function name="user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password. Only supervisors can change other users' passwords.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM user_supervisor_assert(_uid);

	SELECT user_id INTO _user_id FROM account WHERE login = _login;
	IF NOT FOUND THEN PERFORM charp_raise('NOTFOUND'); END IF;

	PERFORM av.user_password_change (_user_id, _plain_password);
END;]]></definition>
</function>

<function name="user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password with the given plain-text password. Return the newly generated salt.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
	_login account.login%TYPE;
BEGIN
	_salt := pgcrypto.gen_salt ('bf', 8);
	UPDATE account 
		SET salt = _salt,
			password = pgcrypto.crypt (_plain_password, _salt)
		WHERE user_id = _user_id AND status = 'active'
		RETURNING login INTO _login;

	IF NOT FOUND THEN
		PERFORM charp_raise('USERDIS', _login::text);
	END IF;

	RETURN _salt;
END;]]></definition>
</function>

<function name="solution_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	RETURN activation_solve_challenge (rp.activation_challenge_get (1::uid));
END;]]></definition>
</function>

<function name="log_in"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the authenticated user has never begun a session.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	INSERT INTO user_activity
		SELECT _uid, current_timestamp, terminal_validate (_remote_addr), 'login', NULL;

	UPDATE account SET is_first = FALSE 
		WHERE user_id = _uid AND is_first = TRUE;
	RETURN FOUND;
END;]]></definition>
</function>

<function name="this_terminal_info_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get credentials and general info on the terminal from where the user connects.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<parameter name="terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="term_type">
		<type name="av.terminal_type" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="qz_private_key">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="qz_certificate">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="shift_user">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT terminal_id, term_type, name, qz_private_key, qz_certificate, login
	FROM terminal 
		NATURAL LEFT JOIN cashier_shift
		NATURAL LEFT JOIN account
	WHERE ip_addr = _remote_addr;]]></definition>
</function>

<index name="ticket_uq" table="av.ticket"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[There cannot be two tickets of the same type printed by the same terminal at the same time.]]></comment>
		<idxelement use-sorting="false">
			<column name="terminal_id"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="&quot;timestamp&quot;"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="false" asc-order="true">
			<column name="type"/>
		</idxelement>
</index>

<relationship name="cashier_shift_has_one_user_cashier" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.user_cashier"
	 dst-table="av.cashier_shift"
	 src-required="true" dst-required="false"/>

<function name="log_out"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the authenticated user has never begun a session.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[INSERT INTO user_activity
	SELECT _uid, current_timestamp, terminal_validate (_remote_addr), 'logout', NULL;]]></definition>
</function>

<function name="ticket_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_timestamp">
		<type name="av.ts" length="0"/>
	</parameter>
	<parameter name="_type">
		<type name="av.ticket_type" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
END
]]></definition>
</function>

<relationship name="account_has_many_ticket" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.ticket"
	 src-required="true" dst-required="false"/>

<function name="terminal_validate"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Return terminal_id given the remote address. Raise exception if not found (connecting from unauthorized IP).]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="smallint" length="0"/>
	</return-type>
	<parameter name="_remote_addr">
		<type name="inet" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
BEGIN
	SELECT terminal_id INTO _terminal_id FROM terminal WHERE ip_addr = _remote_addr;
	IF NOT FOUND THEN PERFORM charp_raise ('USERPERM'); END IF;
	RETURN _terminal_id;
END;]]></definition>
</function>

<function name="anon_supervisor_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Create a supervisor user IF there are no supervisors already. For activatioin only.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_new_user_id av.account.user_id%TYPE;
BEGIN
	IF NOT rp.anon_system_is_activated() OR rp.anon_supervisor_created() THEN
		PERFORM charp_raise ('USERPERM');
	END IF;

	_new_user_id := user_create (1::uid, _login, _password, NULL);
	PERFORM user_role_add (_new_user_id, 'supervisor');
END;]]></definition>
</function>

<function name="anon_user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password using a one-time support challenge.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_solution">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM 1 FROM supervisor_challenge WHERE string = _chal AND user_id = 1::uid;
	IF NOT FOUND THEN PERFORM charp_raise ('USERPERM'); END IF;

	-- one-time challenge. Discard.
	DELETE FROM supervisor_challenge WHERE string = _chal;

	IF _solution IS NULL OR _solution <> activation_solve_challenge (_chal) THEN
		PERFORM charp_raise ('EXIT', 'BAD_SOLUTION');
	END IF;	

	_user_id := charp_account_get_id_by_login_status (_login, 'active');

	PERFORM av.user_password_change (_user_id, _plain_password);
END;]]></definition>
</function>

<function name="user_supervisor_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that the given uid is from a supervisor. If not, raise exception.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM 1 FROM user_supervisor WHERE user_id = _user_id;
	IF NOT FOUND THEN PERFORM charp_raise('USERPERM'); END IF;
END;]]></definition>
</function>

<function name="cashier_shift_begin"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Register a shift in cashier_shift and a deposit ticket/payment for the amount provided.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_deposit_amount">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_ticket_id av.ticket.ticket_id%TYPE;
BEGIN
	PERFORM user_cashier_assert(_uid);
	_terminal_id := terminal_validate(_remote_addr);

	PERFORM 1 FROM cashier_shift WHERE terminal_id = _terminal_id OR user_id = _uid;
	IF FOUND THEN PERFORM charp_raise ('DATADUP'); END IF;

	INSERT INTO cashier_shift VALUES (_terminal_id, _uid, CURRENT_TIMESTAMP);
	INSERT INTO user_activity VALUES (_uid, CURRENT_TIMESTAMP, _terminal_id, 'shift_begin', NULL);

	INSERT INTO ticket VALUES (DEFAULT, _terminal_id, _uid, CURRENT_TIMESTAMP, 'deposit', NULL)
		RETURNING ticket_id INTO _ticket_id;

	INSERT INTO movement VALUES (_ticket_id, CURRENT_TIMESTAMP, NULL, 'tender', _deposit_amount, NULL, NULL);
END;]]></definition>
</function>

<function name="user_cashier_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that the given uid is from a cashier. If not, raise exception.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM 1 FROM user_cashier WHERE user_id = _user_id;
	IF NOT FOUND THEN PERFORM charp_raise('USERPERM'); END IF;
END;]]></definition>
</function>

<index name="cashier_shift_user_uq" table="av.cashier_shift"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[A cashier can only have one shift begun at a given time.]]></comment>
		<idxelement use-sorting="false">
			<column name="user_id"/>
		</idxelement>
</index>

<function name="cashier_park_charge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Registers the charge of temporary parking.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_entry_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_charge_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_ticket_type">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_rate_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_method">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_reference">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_ticket_id ticket.ticket_id%TYPE;
	_last_event av.ts;
	_rate_id av.rate.rate_id%TYPE;
BEGIN
	_terminal_id := cashier_shift_assert (_uid, _remote_addr);

	_last_event := cashier_shift_update_last_event (_uid, _terminal_id);
	IF _charge_ts < _last_event THEN 
		PERFORM charp_raise ('USERPERM'); -- exception will rollback previous update
	END IF;

	INSERT INTO ticket VALUES (DEFAULT, _terminal_id, _uid, _entry_ts, _ticket_type::av.ticket_type, NULL)
		RETURNING ticket_id INTO _ticket_id;

	INSERT INTO movement
		SELECT _ticket_id, _charge_ts, rate_id, _method::av.payment_type, _amount, _change, _reference
			FROM rate WHERE rate.name = _rate_name AND rate.type = 'regular'
        RETURNING rate_id INTO _rate_id;

	IF _rate_id IS NULL THEN PERFORM charp_raise ('ASSERT', 'Rate "' || _rate_name || '" not found'); END IF;
END;]]></definition>
</function>

<function name="cashier_shift_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[In one query, check that the user is a cashier and the remote address is of a terminal where the user has a shift begun. Return terminal_id.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="smallint" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
BEGIN
	SELECT terminal_id INTO _terminal_id 
		FROM cashier_shift NATURAL JOIN terminal
		WHERE ip_addr = _remote_addr AND user_id = _user_id;

	IF NOT FOUND THEN PERFORM charp_raise ('USERPERM'); END IF;

	RETURN _terminal_id;
END;]]></definition>
</function>

<function name="cashier_shift_update_last_event"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Update the last_event field with NOW. Assumes the cashier shift has already been validated.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</return-type>
	<parameter name="_user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="_terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_last_event av.ts;
BEGIN
	SELECT last_event INTO _last_event FROM cashier_shift
		WHERE terminal_id = _terminal_id AND user_id = _user_id;

	UPDATE cashier_shift SET last_event = CURRENT_TIMESTAMP 
		WHERE terminal_id = _terminal_id AND user_id = _user_id;

	RETURN _last_event;
END;]]></definition>
</function>

<function name="cashier_park_charge_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the ticket exists and has not been already charged. Register the user's intention to charge.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_ticket_terminal_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_ticket_entry_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_ticket_id av.ticket.ticket_id%TYPE;
	_movement_ts av.movement.timestamp%TYPE;
BEGIN
	_terminal_id := cashier_shift_assert (_uid, _remote_addr);

	PERFORM 1 FROM ticket
		WHERE terminal_id = _ticket_terminal_id
			AND timestamp = _ticket_entry_ts;

	IF FOUND THEN PERFORM charp_raise ('DATADUP'); END IF;

	INSERT INTO user_activity
		VALUES (_uid, CURRENT_TIMESTAMP, _terminal_id, 'charge_check', 
			jsonb_build_object ('terminal_id', _ticket_terminal_id, 'timestamp', _ticket_entry_ts));
END;]]></definition>
</function>

<index name="rate_uq" table="av.rate"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[Rates are unique by name.]]></comment>
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
</index>

<constraint name="account_creator_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="av.account" table="av.account">
	<columns names="creator_user_id" ref-type="src-columns"/>
	<columns names="user_id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_account_account" type="relfk"
	 src-table="av.account"
	 dst-table="av.account"
	 src-required="false" dst-required="false">
	<line>
		<position x="429.716" y="1239.82"/>
	<position x="429.716" y="1169"/>
	<position x="292.477" y="1169"/>
	</line>
	<label ref-type="dst-label">
		<position x="-5.86667" y="1.8"/>
	</label>
</relationship>

<permission>
	<object name="avanty" type="database"/>
	<roles names="avanty"/>
	<privileges connect="true"/>
</permission>
<permission>
	<object name="pgcrypto" type="schema"/>
	<roles names="avanty"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="av.request" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.account" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="rp" type="schema"/>
	<roles names="avanty"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="av.request_log" type="table"/>
	<roles names="avanty"/>
	<privileges insert="true"/>
</permission>
<permission>
	<object name="av.user_supervisor" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.user_cashier" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.user_maintenance" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.terminal" type="table"/>
	<roles names="avanty"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="av.ticket" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.cashier_shift" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="av.user_activity" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.supervisor_challenge" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="av.movement" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.rate" type="table"/>
	<roles names="avanty"/>
	<privileges select="true"/>
</permission>
</dbmodel>
