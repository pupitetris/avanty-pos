<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.9.1-beta1" author="Arturo Espinosa" last-position="406,765" last-zoom="0.8"
	 default-schema="av" default-owner="postgres">
<role name="avanty"
      login="true"
      encrypted="true"
      password="123">
	<comment><![CDATA[Low-security user for operation of the avanty system.]]></comment>
	<appended-sql><![CDATA[ALTER USER avanty SET search_path TO av,public;]]></appended-sql>
	<prepended-sql><![CDATA[DROP ROLE IF EXISTS avanty;]]></prepended-sql>
</role>

<database name="avanty" encoding="UTF8" template="template0" is-template="false" allow-conns="true" append-at-eod="true">
	<comment><![CDATA[ver. 1.0.2]]></comment>
	<appended-sql><![CDATA[ALTER DATABASE avanty SET search_path TO av,public;

GRANT USAGE ON SEQUENCE av.account_user_id_seq TO avanty;
GRANT USAGE ON SEQUENCE av.ticket_ticket_id_seq TO avanty;
GRANT USAGE ON SEQUENCE av.cashier_shift_shift_id_seq TO avanty;
]]></appended-sql>
</database>

<schema name="public" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="av" fill-color="#e1e1e1">
	<role name="avanty"/>
</schema>

<domain name="uid" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Special type for user id's to be automatically recognized by the rpc system.]]></comment>
	<type name="smallint" length="0"/>
	<constraint name="uid_limits" type="check">
		<expression><![CDATA[VALUE >= 1 AND VALUE < 32768]]></expression>
	</constraint>
</domain>

<domain name="ts" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[just a short name for " timestamp with time zone"]]></comment>
	<type name="timestamp with time zone" length="0" with-timezone="true"/>
</domain>

<schema name="pgcrypto" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
	<comment><![CDATA[Separate schema for all cryptographic functions to avoid pollution.]]></comment>
</schema>

<extension name="pgcrypto">
	<schema name="pgcrypto"/>
	<comment><![CDATA[Cryptographic routines.]]></comment>
</extension>

<table name="user_cashier" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type cashier.]]></comment>
	<position x="640" y="1300"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="user_cashier_pk" index="0"/>
	</customidxs>
</table>

<usertype name="charp_account_status" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="active,disabled,deleted"/>
</usertype>

<usertype name="charp_error_code" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="USERUNK,USERDIS,PROCUNK,REQUNK,REPFAIL,ASSERT,USERPARMPERM,USERPERM,MAILFAIL,DATADUP,NOTFOUND,EXIT,SUCCESS"/>
</usertype>

<table name="user_supervisor" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type supervisor.]]></comment>
	<position x="640" y="1360"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="user_supervisor_pk" index="0"/>
	</customidxs>
</table>

<table name="account" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[user accounts]]></comment>
	<position x="40" y="1180"/>
	<column name="user_id" not-null="true">
		<type name="smallserial" length="0"/>
		<comment><![CDATA[Independent ID for users, to allow for login name changes.]]></comment>
	</column>
	<column name="creator_user_id">
		<type name="smallint" length="0"/>
		<comment><![CDATA[uid of the user that created this user.]]></comment>
	</column>
	<column name="login" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Handle specified by the user for credentials.]]></comment>
	</column>
	<column name="salt" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Random per-user salt to make password hash cracking difficult.]]></comment>
	</column>
	<column name="password" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Salted sha512 hash of user-provided password.]]></comment>
	</column>
	<column name="password_expiration">
		<type name="av.ts" length="0" with-timezone="true"/>
		<comment><![CDATA[Forces the user to set a new password upon login if the timestamp has expired.]]></comment>
	</column>
	<column name="status" not-null="true">
		<type name="av.charp_account_status" length="0"/>
		<comment><![CDATA[only active users may run requests to the server]]></comment>
	</column>
	<column name="is_first" not-null="true" default-value="TRUE">
		<type name="boolean" length="0"/>
		<comment><![CDATA[true if the user has never opened session.]]></comment>
	</column>
	<column name="created" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Time of creation.]]></comment>
	</column>
	<constraint name="account_pk" type="pk-constr" table="av.account">
		<columns names="user_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="check_account_login" type="ck-constr" table="av.account">
			<expression><![CDATA[login ~ '^[a-zA-Z0-9_.áéíóúñÁÉÚÍÓÚÑüÜ]+$']]></expression>
		<comment><![CDATA[Restrictions to the login string.]]></comment>
	</constraint>
	<constraint name="check_account_login_unique" type="uq-constr" table="av.account">
		<columns names="login" ref-type="src-columns"/>
		<comment><![CDATA[Two users can't have the same login.]]></comment>
	</constraint>
</table>

<table name="user_maintenance" hide-ext-attribs="true">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[existence table to report if a user is of type maintenance.]]></comment>
	<position x="640" y="1420"/>

	<customidxs object-type="column">
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="0"/>
		<object name="user_maintenance_pk" index="1"/>
	</customidxs>
</table>

<relationship name="user_maintenance_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_maintenance"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="user_cashier_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_cashier"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<usertype name="user_activity_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[other activities may be added later]]></comment>
	<enumeration values="login,logout,shift_begin,shift_end,charge_check"/>
</usertype>

<table name="user_activity">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[logs login/logout actions from the users for the user report for the supervisor]]></comment>
	<position x="600" y="1180"/>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[when the activity occurred]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="av.user_activity_type" length="0"/>
	</column>
	<column name="detail">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[additional key/values for future flexibility]]></comment>
	</column>
	<constraint name="user_activity_pk" type="pk-constr" table="av.user_activity">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="terminal_id" index="2"/>
		<object name="user_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
		<object name="terminal_fk" index="2"/>
	</customidxs>
</table>

<relationship name="account_has_many_user_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_activity"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"
	upd-action="NO ACTION"
	del-action="NO ACTION"/>

<table name="supervisor_challenge">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[We are keeping a registry of all challenges, for security audits.]]></comment>
	<position x="1080" y="1460"/>
	<column name="string" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[A random-generated string that the supervisor must give to support.]]></comment>
	</column>
	<column name="created" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="expiration">
		<type name="av.ts" length="0"/>
	</column>
	<column name="solution">
		<type name="varchar" length="0"/>
		<comment><![CDATA[The solution that was provided by support. A correct solution will activate the system.]]></comment>
	</column>
	<constraint name="supervisor_challenge_pk" type="pk-constr" table="av.supervisor_challenge">
		<columns names="string" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="user_supervisor_fk" index="1"/>
	</customidxs>
</table>

<usertype name="terminal_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="user_pos,boom_entry,boom_exit,tvm"/>
</usertype>

<table name="terminal">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Table with terminal info. entry_consecutive is updated every time a ticket is printed.]]></comment>
	<position x="20" y="780"/>
	<column name="terminal_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="term_type" not-null="true">
		<type name="av.terminal_type" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[what to show on the UI]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[IP Address that identifies this terminal]]></comment>
	</column>
	<column name="entry_consecutive" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[A serial number for entry tickets which is independent for each terminal.]]></comment>
	</column>
	<column name="shift_consecutive" not-null="true" default-value="0">
		<type name="integer" length="0"/>
		<comment><![CDATA[Consecutive number for shifts assigned to this terminal.]]></comment>
	</column>
	<column name="qz_private_key">
		<type name="text" length="0"/>
		<comment><![CDATA[Private RSA key for qz-tray request signing.]]></comment>
	</column>
	<column name="qz_certificate">
		<type name="text" length="0"/>
		<comment><![CDATA[OpenSSL certificate to grant connection to the qz-tray server.]]></comment>
	</column>
	<constraint name="terminal_pk" type="pk-constr" table="av.terminal">
		<columns names="terminal_id" ref-type="src-columns"/>
	</constraint>
</table>

<relationship name="terminal_has_many_user_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.terminal"
	 dst-table="av.user_activity"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<usertype name="ticket_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="entry,exit,rent,deposit,withdrawal,lost"/>
</usertype>

<table name="ticket">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[a printed ticket]]></comment>
	<position x="1500" y="1080"/>
	<column name="ticket_id" not-null="true">
		<type name="serial" length="0"/>
		<comment><![CDATA[Only the last digit is used in the printout.]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.ticket_type" length="0"/>
	</column>
	<column name="detail">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[Documenting data with details printed on the ticket.]]></comment>
	</column>
	<constraint name="ticket_pk" type="pk-constr" table="av.ticket">
		<columns names="ticket_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="shift_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="cashier_shift_fk" index="1"/>
	</customidxs>
</table>

<usertype name="rate_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="regular,lost,rent,fragment,system"/>
</usertype>

<table name="rate">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Rate scripts written in Forth for rate processing. Fragment type scripts are not final scripts, they are to be included from other scripts.]]></comment>
	<position x="1500" y="1680"/>
	<column name="rate_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[For UI purposes, for the rate selector.]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="av.rate_type" length="0"/>
	</column>
	<column name="is_active" not-null="true">
		<type name="boolean" length="0"/>
		<comment><![CDATA[Rates may be deactivated and not used any more, but we keep them for bookkeeping.]]></comment>
	</column>
	<column name="script" not-null="true" default-value="''">
		<type name="varchar" length="0"/>
		<comment><![CDATA[a DSL to be executed to itemize the payment and generate a total.]]></comment>
	</column>
	<column name="description" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[documentation text for the management console.]]></comment>
	</column>
	<column name="position" not-null="true">
		<type name="smallint" length="0"/>
		<comment><![CDATA[Order in which an active rate will appear on the interface.]]></comment>
	</column>
	<column name="label">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Name that appears on the UI for rate selection.]]></comment>
	</column>
	<column name="label_client">
		<type name="varchar" length="0"/>
		<comment><![CDATA[Label to be displayed on the client's screen (VFD)]]></comment>
	</column>
	<constraint name="rate_pk" type="pk-constr" table="av.rate">
		<columns names="rate_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="check_rate_label_not_null_if_not_fragment" type="ck-constr" table="av.rate">
			<expression><![CDATA[type = 'fragment' OR type = 'system' OR (label IS NOT NULL AND label <> '')]]></expression>
		<comment><![CDATA[Rates that are not fragments need a label to be defined and not empty string so they can be shown on ui.]]></comment>
	</constraint>
</table>

<usertype name="payment_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Payment methods]]></comment>
	<enumeration values="tender,credit_card,debit_card"/>
</usertype>

<table name="movement">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="1900" y="1300"/>
	<column name="timestamp" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="method" not-null="true">
		<type name="av.payment_type" length="0"/>
	</column>
	<column name="amount" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[in cents]]></comment>
	</column>
	<column name="change">
		<type name="integer" length="0"/>
		<comment><![CDATA[in cents. May be null if does not apply for payment method.]]></comment>
	</column>
	<column name="reference">
		<type name="varchar" length="0"/>
		<comment><![CDATA[For electrnoic payments, a reference string to conciliate accounting.]]></comment>
	</column>

	<customidxs object-type="column">
		<object name="rate_id" index="2"/>
		<object name="ticket_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_pk" index="1"/>
		<object name="rate_fk" index="0"/>
		<object name="ticket_fk" index="2"/>
	</customidxs>
</table>

<relationship name="rate_has_many_payment" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.movement"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<usertype name="tender_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="coin,bill"/>
</usertype>

<table name="tender">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[catalog, describes a coin or a bill]]></comment>
	<position x="1900" y="1500"/>
	<column name="tender_id" not-null="true">
		<type name="smallserial" length="0"/>
	</column>
	<column name="denomination" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[in cents]]></comment>
	</column>
	<column name="type" not-null="true">
		<type name="av.tender_type" length="0"/>
	</column>
	<constraint name="tender_pk" type="pk-constr" table="av.tender">
		<columns names="tender_id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="exchange_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="received,change"/>
</usertype>

<table name="tender_exchange">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="2300" y="1380"/>
	<column name="type" not-null="true">
		<type name="av.exchange_type" length="0"/>
	</column>
	<column name="count" not-null="true">
		<type name="smallint" length="0"/>
		<comment><![CDATA[how many of this bill or coin]]></comment>
	</column>

	<customidxs object-type="column">
		<object name="tender_id" index="1"/>
		<object name="ticket_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_fk" index="2"/>
		<object name="tender_exchange_pk" index="0"/>
		<object name="tender_fk" index="1"/>
	</customidxs>
</table>

<relationship name="tender_has_many_tender_exchange" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.tender"
	 dst-table="av.tender_exchange"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<table name="owner">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[A person or company owning a vehicle]]></comment>
	<position x="2640" y="1000"/>
	<column name="owner_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="name" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="address">
		<type name="varchar" length="0"/>
		<comment><![CDATA[all of the address, as an open field]]></comment>
	</column>
	<column name="fiscal_code">
		<type name="varchar" length="0"/>
	</column>
	<column name="fiscal_address">
		<type name="varchar" length="0"/>
		<comment><![CDATA[open field]]></comment>
	</column>
	<column name="phone">
		<type name="varchar" length="0"/>
	</column>
	<constraint name="owner_pk" type="pk-constr" table="av.owner">
		<columns names="owner_id" ref-type="src-columns"/>
	</constraint>
</table>

<usertype name="vehicle_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="motorcycle,compact,regular,light_truck,truck,special"/>
</usertype>

<table name="vehicle">
	<schema name="av"/>
	<role name="postgres"/>
	<position x="3080" y="1060"/>
	<column name="vehicle_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="plate" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.vehicle_type" length="0"/>
	</column>
	<column name="make" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="model" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<column name="year" not-null="true">
		<type name="smallint" length="0"/>
	</column>
	<column name="color" not-null="true">
		<type name="varchar" length="0"/>
	</column>
	<constraint name="vehicle_pk" type="pk-constr" table="av.vehicle">
		<columns names="vehicle_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="owner_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="owner_fk" index="1"/>
	</customidxs>
</table>

<relationship name="owner_has_many_vehicle" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.owner"
	 dst-table="av.vehicle"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<table name="rent">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[a car pension]]></comment>
	<position x="3500" y="1200"/>
	<column name="rent_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="expiration" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="is_cancelled" not-null="true">
		<type name="boolean" length="0"/>
	</column>
	<column name="card_number">
		<type name="varchar" length="0"/>
		<comment><![CDATA[ID of the contactless card]]></comment>
	</column>
	<column name="last_in">
		<type name="av.ts" length="0"/>
	</column>
	<column name="last_out">
		<type name="av.ts" length="0"/>
	</column>
	<constraint name="rent_pk" type="pk-constr" table="av.rent">
		<columns names="rent_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rate_id" index="3"/>
		<object name="ticket_id" index="2"/>
		<object name="vehicle_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="rate_fk" index="4"/>
		<object name="rent_uq" index="2"/>
		<object name="ticket_fk" index="1"/>
		<object name="vehicle_fk" index="3"/>
	</customidxs>
</table>

<relationship name="rent_has_one_ticket" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.ticket"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="vehicle_has_many_rent" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.vehicle"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="rate_has_many_rent" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.rent"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<usertype name="rent_operation_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="new,edit,renew,expired,cancelled,reactivated,rate_change"/>
</usertype>

<table name="rent_operation">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[history of operations regarding a rent account]]></comment>
	<position x="3980" y="1440"/>
	<column name="timestamp" not-null="true">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.rent_operation_type" length="0"/>
	</column>
	<constraint name="rent_operation_pk" type="pk-constr" table="av.rent_operation">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rate_id" index="2"/>
		<object name="rent_id" index="0"/>
		<object name="ticket_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="movement_fk" index="3"/>
		<object name="rate_fk" index="2"/>
		<object name="rent_fk" index="1"/>
		<object name="rent_operation_uq" index="4"/>
	</customidxs>
</table>

<relationship name="rent_has_many_rent_operation" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.rent"
	 dst-table="av.rent_operation"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="rate_has_many_rent_operation" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.rate"
	 dst-table="av.rent_operation"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<usertype name="rent_activity_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<enumeration values="in,out"/>
</usertype>

<table name="rent_activity">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[when a vehicle in rented parking left or came into the lot]]></comment>
	<position x="3980" y="1260"/>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
	</column>
	<column name="type" not-null="true">
		<type name="av.rent_activity_type" length="0"/>
	</column>
	<constraint name="rent_activity_pk" type="pk-constr" table="av.rent_activity">
		<columns names="timestamp" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="rent_id" index="0"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="rent_fk" index="1"/>
	</customidxs>
</table>

<relationship name="rent_has_many_rent_activity" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.rent"
	 dst-table="av.rent_activity"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<table name="cashier_shift">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[who is logged in in what terminal]]></comment>
	<position x="1080" y="1020"/>
	<column name="shift_id" not-null="true">
		<type name="serial" length="0"/>
	</column>
	<column name="consecutive" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[Consecutive number, where terminal_id,consecutive is unique.]]></comment>
	</column>
	<column name="last_event" not-null="true">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[TS of last interactive event, to avoid insertion of events (tickets, movements) with arbitrary dates]]></comment>
	</column>
	<column name="shift_start" not-null="true">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Timestamp when the shift begun.]]></comment>
	</column>
	<column name="shift_end">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Optional timestamp of when the shift ended, NULL if not closed yet.]]></comment>
	</column>
	<constraint name="cashier_shift_pk" type="pk-constr" table="av.cashier_shift">
		<columns names="shift_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="terminal_id" index="1"/>
		<object name="user_id" index="2"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="terminal_fk" index="2"/>
		<object name="user_cashier_fk" index="1"/>
	</customidxs>
</table>

<table name="request">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[RPC requests being currently handled by CHARP (Challenge-Authenticated Remote Procedures)]]></comment>
	<appended-sql><![CDATA[GRANT USAGE ON SEQUENCE request_request_id_seq TO avanty;]]></appended-sql>
	<position x="600" y="1580"/>
	<column name="request_id" not-null="true">
		<type name="serial" length="0"/>
		<comment><![CDATA[id of this request currently being processed. will be copied to request_log as soon as its life has ended.]]></comment>
	</column>
	<column name="random_bytes" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[hex representation of random bytes sent to client as a challenge.]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Stamp of when the request started. Requests that are too old will be removed by pgAgent.]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[originating public IP Address, as reported by the web server.]]></comment>
	</column>
	<column name="proname" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[name of the stored procedure that was requested]]></comment>
	</column>
	<column name="params" not-null="true">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[parameters to the request stored procedure execution]]></comment>
	</column>
	<constraint name="request_pk" type="pk-constr" table="av.request">
		<columns names="request_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
	</customidxs>
</table>

<relationship name="account_has_many_request" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.request"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<usertype name="charp_request_status" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[CHARP request, logs how a request finished]]></comment>
	<enumeration values="success,exception,timeout"/>
</usertype>

<table name="request_log">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[CHARP requests log, for auditing]]></comment>
	<position x="580" y="1720"/>
	<column name="request_log_id" not-null="true">
		<type name="integer" length="0"/>
		<comment><![CDATA[this is copied from request table but can't be FK because it will be deleted from request]]></comment>
	</column>
	<column name="timestamp" not-null="true" default-value="CURRENT_TIMESTAMP">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[Stamp of when the request started. Requests that are too old will be removed by pgAgent.]]></comment>
	</column>
	<column name="error_code" not-null="true">
		<type name="av.charp_error_code" length="0"/>
		<comment><![CDATA[Use SUCCESS if no error was produced.]]></comment>
	</column>
	<column name="login" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[The username that was used during the request.]]></comment>
	</column>
	<column name="ip_addr" not-null="true">
		<type name="inet" length="0"/>
		<comment><![CDATA[originating public IP Address, as reported by the web server.]]></comment>
	</column>
	<column name="proname" not-null="true">
		<type name="varchar" length="0"/>
		<comment><![CDATA[name of the stored procedure that was requested]]></comment>
	</column>
	<column name="params">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[parameters to the request stored procedure execution]]></comment>
	</column>
	<column name="err_params">
		<type name="jsonb" length="0"/>
		<comment><![CDATA[The parameters that came from the raised exception.]]></comment>
	</column>
	<column name="finished" not-null="true">
		<type name="av.ts" length="0"/>
		<comment><![CDATA[When the request was added to the log (either if it succeeded, was error, or time out)]]></comment>
	</column>
	<column name="status" not-null="true">
		<type name="av.charp_request_status" length="0"/>
		<comment><![CDATA[under what circumstances the request was logged]]></comment>
	</column>
	<constraint name="request_pk_1" type="pk-constr" table="av.request_log">
		<columns names="request_log_id" ref-type="src-columns"/>
	</constraint>

	<customidxs object-type="column">
		<object name="user_id" index="1"/>
	</customidxs>

	<customidxs object-type="constraint">
		<object name="account_fk" index="1"/>
	</customidxs>
</table>

<relationship name="account_has_many_request_log" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.request_log"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="user_supervisor_has_one_account" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.account"
	 dst-table="av.user_supervisor"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<index name="user_login_uniq" table="av.account"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[logins must be unique.]]></comment>
		<idxelement use-sorting="false">
			<column name="login"/>
		</idxelement>
</index>

<usertype name="charp_param_type" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[parameters that can be mapped by the CHARP RPC system.]]></comment>
	<enumeration values="UID,INT,STR,BOOL,DATE,INTARR,STRARR,BOOLARR,REMOTE_ADDR,TS,SMINT,SMINTARR"/>
</usertype>

<usertype name="charp_cmd_code" configuration="enumeration">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[commands that the DB can send to the web gateway through the notification system]]></comment>
	<enumeration values="FILE_CREATE,FILE_DELETE,FILE_MOVE,FILE_COPY,EXIT,OTHER"/>
</usertype>

<relationship name="payment_has_one_ticket" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.ticket"
	 dst-table="av.movement"
	 src-required="true" dst-required="false"
	 identifier="true"
/>

<relationship name="payment_has_many_tender_exchange" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.movement"
	 dst-table="av.tender_exchange"
	 src-required="true" dst-required="false"
	 identifier="true"

	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="rent_operation_has_one_payment" type="rel11"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.movement"
	 dst-table="av.rent_operation"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<schema name="rp" rect-visible="true" fill-color="#e1e1e1">
	<role name="postgres"/>
	<comment><![CDATA[Stored procedures that can be called from the CHARP gateway.]]></comment>
</schema>

<function name="charp_log_error"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Send an error report to the request log, optionally (based on request_id) moving data from av.request to log the lifecycle of a given request.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_request_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_code">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_proname">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_err_params">
		<type name="jsonb" length="0"/>
	</parameter>
	<parameter name="_status">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id account.user_id%TYPE;
BEGIN
	IF _login IS NOT NULL THEN
		SELECT user_id INTO _user_id FROM account WHERE login = _login;
	END IF;

	IF _request_id IS NULL THEN
		_request_id := nextval('request_request_id_seq');
		INSERT INTO
			request_log (request_log_id, user_id, timestamp, error_code,
				login, ip_addr, proname, params, err_params,
				finished, status)
			VALUES (_request_id, _user_id, CURRENT_TIMESTAMP, _code::charp_error_code,
				_login, _ip_addr, _proname, NULL, _err_params,
				CURRENT_TIMESTAMP, _status::charp_request_status);
	ELSE
		INSERT INTO
			request_log (request_log_id, user_id, timestamp, error_code,
				login, ip_addr, proname, params, err_params,
				finished, status)
			SELECT r.request_id, r.user_id, r.timestamp, _code::charp_error_code, 
				_login, r.ip_addr, r.proname, r.params, _err_params, 
				CURRENT_TIMESTAMP, _status::charp_request_status
				FROM request AS r WHERE r.request_id = _request_id;
		DELETE FROM request WHERE request_id = _request_id;
	END IF;
END;]]></definition>
</function>

<function name="charp_raise"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Raise and log an exception with the CHARP format for client consumption. WARNING: exceptions cause all data changes to be rolled back! Use charp_cmd to avoid rollbacks.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_code">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_args" variadic="true" default-value="ARRAY[]::text[]">
		<type name="varchar" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_i integer;
	_sqlcode text;
	_code_t charp_error_code;
BEGIN
	IF substring(_code FROM 1 FOR 1) = '-' THEN
	   _code_t := substring(_code FROM 2);
	ELSE
	   _code_t := _code;
	END IF;

	SELECT INTO _sqlcode
	       CASE _code_t
		    WHEN 'USERUNK'      THEN 'RP001'
			WHEN 'USERDIS'      THEN 'RP002'
		    WHEN 'PROCUNK'      THEN 'RP003'
		    WHEN 'REQUNK'       THEN 'RP004'
		    WHEN 'REPFAIL'      THEN 'RP005'
		    WHEN 'ASSERT'       THEN 'RP006'
		    WHEN 'USERPARMPERM' THEN 'RP007'
		    WHEN 'USERPERM'     THEN 'RP008'
		    WHEN 'MAILFAIL'     THEN 'RP009'
		    WHEN 'DATADUP'      THEN 'RP010'
		    WHEN 'NOTFOUND'     THEN 'RP011'
		    WHEN 'EXIT'         THEN 'RP012'
		    ELSE 'RP000'
	       END;

	RAISE EXCEPTION '|>%|%|', _code, array_to_json(_args) USING ERRCODE = _sqlcode;
END;]]></definition>
</function>

<function name="charp_cmd"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Send a command to the CHARP CGI layer. Unlike charp_raise, this won't create an exception that will rollback the current transaction.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_cmd">
		<type name="av.charp_cmd_code" length="0"/>
	</parameter>
	<parameter name="_args" variadic="true" default-value="ARRAY[]::text[]">
		<type name="text" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_i integer;
BEGIN
	RAISE INFO '|>%|%|', _cmd::text, array_to_json(_args);
END;]]></definition>
</function>

<function name="charp_rp_get_function_by_name"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Find given function within rp schema, raise PROCUNK if not found.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_name varchar;
BEGIN
	SELECT proname INTO _name 
		FROM pg_proc AS p 
			JOIN pg_namespace AS ns
				ON (p.pronamespace = ns.oid)
		WHERE p.proname = _function_name AND ns.nspname = 'rp';
	IF NOT FOUND THEN
	   PERFORM charp_raise('PROCUNK', _function_name);
	END IF;
	RETURN _name;
END;]]></definition>
</function>

<function name="charp_request_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Registers a request returning a corresponding challlenge for the client to respond.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_params">
		<type name="jsonb" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_random_bytes character varying;
BEGIN
	_random_bytes := encode(pgcrypto.gen_random_bytes(32), 'hex');
	INSERT INTO
		request (request_id, user_id,
			random_bytes, timestamp, ip_addr, proname, 
			params)
		VALUES (DEFAULT,	charp_account_get_id_by_login_status(_login, 'active'),
			_random_bytes, CURRENT_TIMESTAMP, _ip_addr, charp_rp_get_function_by_name(_function_name),
			_params);

	RETURN _random_bytes;
END;]]></definition>
</function>

<function name="charp_get_function_params"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Convert the parameter array of a function for given oids to charp_param_type.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="av.charp_param_type" length="0" dimension="1"/>
	</return-type>
	<parameter name="_proargtypes">
		<type name="oidvector" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_fparams charp_param_type ARRAY;
BEGIN
	SELECT ARRAY( 
	       	      SELECT 
			     CASE format_type (_proargtypes[s.i], NULL)
				  WHEN 'uid'	   		 	 THEN 'UID'
				  WHEN 'smallint'		     THEN 'SMINT'
				  WHEN 'integer'		     THEN 'INT'
				  WHEN 'character varying'   THEN 'STR'
				  WHEN 'text'			     THEN 'STR'
				  WHEN 'boolean'		     THEN 'BOOL'
				  WHEN 'date'			     THEN 'DATE'
				  WHEN 'ts'			         THEN 'TS'
				  WHEN 'timestamp'	         THEN 'TS'
				  WHEN 'timestamp with time zone' THEN 'TS'
				  WHEN 'smallint[]'		     THEN 'SMINTARR'
				  WHEN 'integer[]'		     THEN 'INTARR'
				  WHEN 'character varying[]' THEN 'STRARR'
				  WHEN 'text[]'			     THEN 'STRARR'
				  WHEN 'boolean[]'			 THEN 'BOOLARR'
				  WHEN 'remote_addr'		 THEN 'REMOTE_ADDR'
				  ELSE 'STR'
			     END
			     FROM generate_series(0, array_upper(_proargtypes, 1)) AS s(i)
		      ) 
	       INTO _fparams;
	RETURN _fparams;
END;]]></definition>
</function>

<function name="charp_function_params"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Return the input parameter types that a given stored procedure requires.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="av.charp_param_type" length="0" dimension="1"/>
	</return-type>
	<parameter name="_function_name">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_fparams charp_param_type ARRAY;
BEGIN
	SELECT charp_get_function_params (p.proargtypes) INTO _fparams 
		FROM pg_proc AS p 
			JOIN pg_namespace AS ns
				ON (p.pronamespace = ns.oid)
		WHERE p.proname = _function_name AND ns.nspname = 'rp';
	IF NOT FOUND THEN
	   PERFORM charp_raise('PROCUNK', _function_name);
	END IF;
	RETURN _fparams;
END;]]></definition>
</function>

<function name="charp_request_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that a given request is registered with the given data and compare the hash with one locally computed. Return the necessary data to execute.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="request_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="fname">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="fparams">
		<type name="av.charp_param_type" length="0" dimension="1"/>
	</parameter>
	<parameter name="req_params">
		<type name="jsonb" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_ip_addr">
		<type name="inet" length="0"/>
	</parameter>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_hash">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_req RECORD;
	_our_hash varchar;
	_status av.charp_request_status;
BEGIN
	SELECT 
	       r.request_id AS request_id,
	       a.user_id AS user_id,
	       p.proname AS proname, 
	       r.params AS params, 
	       charp_get_function_params (p.proargtypes) AS fparams, 
	       a.password AS password
	       INTO _req
	       FROM request AS r 
	       		NATURAL JOIN account AS a 
	       		NATURAL JOIN pg_proc AS p
	       		JOIN pg_namespace AS ns ON (p.pronamespace = ns.oid)
	       WHERE a.login = _login 
			 AND r.random_bytes = _chal
			 AND r.ip_addr = _ip_addr
			 AND ns.nspname = 'rp';

	IF _req IS NULL THEN
		PERFORM charp_raise('REQUNK', _username, _ip_addr::text, _chal);
	END IF;

	_our_hash := encode(pgcrypto.digest(_login || _chal || _req.password, 'sha256'), 'hex');
	IF _our_hash <> _hash THEN
		PERFORM charp_raise('REPFAIL', _login, _ip_addr::text, _chal, _req.request_id::text);
	END IF;

	request_id := _req.request_id;
	user_id := _req.user_id;
	fname := _req.proname;
	req_params := _req.params;
	fparams := _req.fparams;
	RETURN NEXT;
END;]]></definition>
</function>

<function name="check_url"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that an entrypoint URL was created by the system.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<parameter name="_url">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_hash_pos integer;
	_url_part text;
	_hash_part text;
	_our_hash text;
BEGIN
	_hash_pos := position ('#' IN _url);
	IF _hash_pos < 1 THEN
	   PERFORM charp_raise('ASSERT', 'URL has #');
	END IF;
	
	_url_part := substring (_url FROM 1 FOR _hash_pos - 1);
	_hash_part := substring (_url FROM _hash_pos + 1);
	_our_hash := rp_sign_url(_url_part);

	IF _our_hash = _hash_part THEN
	   RETURN TRUE;
	END IF;
	RETURN FALSE;
END;]]></definition>
</function>

<function name="sign_url"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Generate a signature for a given URL. FIXME: define url_check_hash1 and hash2]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_url">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT encode(digest('M4_DEFN(url_check_hash1)' || _url
	|| 'M4_DEFN(url_check_hash2)', 'sha256'), 'hex')]]></definition>
</function>

<function name="user_auth"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Trivially return TRUE. If the user was authenticated, everything went OK with challenge-request sequence and there is nothing left to do: success.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT TRUE]]></definition>
</function>

<function name="user_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Create a basic user with no user class. Account is activated by default. Returns the new user_id.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="smallint" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password_expiration" default-value="NULL">
		<type name="av.ts" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
	_user_id account.user_id%TYPE;
BEGIN
	_salt := pgcrypto.gen_salt('bf', 8);
	INSERT INTO
		account (user_id, creator_user_id, login, salt,
			password, 
			password_expiration, status, is_first, created)
		VALUES (DEFAULT, _uid, _login, _salt, 
			pgcrypto.crypt(_plain_password, _salt), 
			_password_expiration, 'active', TRUE, CURRENT_TIMESTAMP) 
		RETURNING user_id INTO _user_id;
	RETURN _user_id;
END;]]></definition>
</function>

<function name="anon_salt_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the salt for the given user so it can be used as a base to generate the encrypted hash of the password client-side, and challenges can be signed using the exact same secrets on both sides.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
BEGIN
	SELECT salt INTO _salt FROM account WHERE login = _login;
	IF NOT FOUND THEN
		PERFORM charp_raise ('USERUNK');
	END IF;

	RETURN _salt;
END;]]></definition>
</function>

<function name="charp_account_get_id_by_login_status"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the user id for a given user name and status, raise USERUNK if not found. NULL status matches any status.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_status">
		<type name="av.charp_account_status" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_id av.account.user_id%TYPE;
	_user_status av.account.status%TYPE;
BEGIN
	SELECT a.user_id, a.status INTO _id, _user_status FROM account AS a
	       WHERE a.login = _login;

	IF NOT FOUND THEN
	   PERFORM charp_raise('USERUNK', _login::text, _status::text);
	END IF;

	IF _status IS NULL OR _status = _user_status THEN
		RETURN _id;
	END IF;

	IF _user_status = 'disabled' THEN
	   PERFORM charp_raise('-USERDIS', _login::text);
	END IF;

	-- user_status is deleted, probably.
	PERFORM charp_raise('USERUNK', _login::text, _status::text);
END;]]></definition>
</function>

<function name="anon_system_is_activated"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[check if the system has already been activated: you need a non-first supervisor account and a correctly signed challenge.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</return-type>
	<definition><![CDATA[DECLARE
	_created timestamptz;
BEGIN
	PERFORM 1 FROM supervisor_challenge
		WHERE user_id = 1::uid
			AND created <= CURRENT_TIMESTAMP
			AND (expiration IS NULL OR expiration > CURRENT_TIMESTAMP)
			AND solution IS NULL;
	IF FOUND THEN RETURN NULL; END IF;

	SELECT created INTO _created FROM supervisor_challenge 
		WHERE user_id = 1::uid 
			AND (expiration IS NULL OR expiration > CURRENT_TIMESTAMP)
			AND activation_solve_challenge (string) = solution
		ORDER BY created DESC LIMIT 1;

	RETURN _created;
END;]]></definition>
</function>

<function name="activation_solve_challenge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Compute the numerical solution for a given challenge.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_challenge">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT array_to_string (
	ARRAY (
		SELECT ascii(q.ch) % 10 
			FROM (
                SELECT unnest (
					regexp_split_to_array (
						substring (
							pgcrypto.crypt (_challenge, '$2a$08$PqR7X.YexgDCsypnT0dFM.'),
							'.{8}$'
                        ), 
					'')
				) AS ch
			) AS q	
		), 
	'')]]></definition>
</function>

<function name="anon_activation_challenge_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[get the activation challenge, which may be generated if none is available.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[DECLARE
	_string av.supervisor_challenge.string%TYPE;
BEGIN
	SELECT string INTO _string
		FROM supervisor_challenge 
		WHERE user_id = 1::uid
			AND created <= CURRENT_TIMESTAMP
			AND (expiration IS NULL OR expiration > CURRENT_TIMESTAMP)
			AND solution IS NULL;

	IF NOT FOUND THEN
		INSERT INTO
			supervisor_challenge (string, user_id, created, expiration, solution)
			VALUES (activation_challenge_gen (), 1::uid, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP + '15 minutes', NULL)
			RETURNING string INTO _string;
	END IF;

	RETURN _string;
END;]]></definition>
</function>

<function name="activation_challenge_gen"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Generate a random string of digits to be solved by the provider's support]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT 
	SUBSTRING (
		regexp_replace (encode (pgcrypto.gen_random_bytes(64), 'hex'), '[a-f]', '', 'g')
	FROM 1 FOR 8)]]></definition>
</function>

<relationship name="user_supervisor_has_many_supervisor_challenge" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.user_supervisor"
	 dst-table="av.supervisor_challenge"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<function name="anon_activation_challenge_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Now check if the given challenge/solution pair is correct.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</return-type>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_solution">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_old_chal av.supervisor_challenge.string%TYPE;
	_created timestamptz;
BEGIN
	_old_chal := rp.anon_activation_challenge_get();

	IF _old_chal <> _chal THEN
		PERFORM charp_raise ('NOTFOUND');
	END IF;

	IF _solution IS NULL OR _solution <> activation_solve_challenge (_chal) THEN
		PERFORM charp_raise ('EXIT', 'BAD_SOLUTION');
	END IF;

	UPDATE supervisor_challenge 
		SET solution = _solution, expiration = NULL
		WHERE string = _chal AND user_id = 1::uid
		RETURNING created INTO _created;

	RETURN _created;
END;]]></definition>
</function>

<domain name="remote_addr" not-null="false">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Used as parameter to RPs, maps at CHARP level to the address of the web client.]]></comment>
	<type name="inet" length="0"/>
</domain>

<function name="anon_supervisor_created"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the system requires an operations supervisor to be created.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<definition><![CDATA[SELECT COUNT(*) > 0 FROM user_supervisor WHERE user_id <> 1;]]></definition>
</function>

<function name="user_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Create an user (only for supervisors).]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_role">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_new_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM user_supervisor_assert(_uid);

	_new_user_id := user_create (_uid, _login, _password, NULL);
	PERFORM user_role_add (_new_user_id, _role);
END;]]></definition>
</function>

<function name="user_role_add"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Set user as part of the given role. Do nothing if it already belongs to given role.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_role">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	CASE _role
		WHEN 'supervisor' THEN
			INSERT INTO user_supervisor (user_id) VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		WHEN 'cashier' THEN
			INSERT INTO user_cashier (user_id) VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		WHEN 'maintenance' THEN
			INSERT INTO user_maintenance (user_id) VALUES (_user_id)
				ON CONFLICT DO NOTHING;
		ELSE
			PERFORM charp_raise ('ASSERT', '_role NOT FOUND');
	END CASE;
END;]]></definition>
</function>

<function name="this_user_types_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get the types this user is in.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<parameter name="cashier">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="supervisor">
		<type name="boolean" length="0"/>
	</parameter>
	<parameter name="maintenance">
		<type name="boolean" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT c.user_id IS NOT NULL as cashier,
	s.user_id IS NOT NULL as supervisor,
    m.user_id IS NOT NULL as maintenance
    FROM account AS a 
    	NATURAL LEFT JOIN user_cashier AS c
    	NATURAL LEFT JOIN user_supervisor AS s 
    	NATURAL LEFT JOIN user_maintenance AS m
        WHERE a.user_id = _uid;]]></definition>
</function>

<function name="this_user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change the password of the calling user. Return the new salt.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	RETURN av.user_password_change (_uid, _plain_password);
END;]]></definition>
</function>

<function name="user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password. Only supervisors can change other users' passwords.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM user_supervisor_assert(_uid);

	SELECT user_id INTO _user_id FROM account WHERE login = _login;
	IF NOT FOUND THEN PERFORM charp_raise('NOTFOUND'); END IF;

	PERFORM av.user_password_change (_user_id, _plain_password);
END;]]></definition>
</function>

<function name="user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password with the given plain-text password. Return the newly generated salt.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_salt account.salt%TYPE;
	_login account.login%TYPE;
BEGIN
	_salt := pgcrypto.gen_salt ('bf', 8);
	UPDATE account 
		SET salt = _salt,
			password = pgcrypto.crypt (_plain_password, _salt)
		WHERE user_id = _user_id AND status = 'active'
		RETURNING login INTO _login;

	IF NOT FOUND THEN
		PERFORM charp_raise('USERDIS', _login::text);
	END IF;

	RETURN _salt;
END;]]></definition>
</function>

<function name="solution_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="varchar" length="0"/>
	</return-type>
	<definition><![CDATA[BEGIN
	RETURN activation_solve_challenge (rp.activation_challenge_get (1::uid));
END;]]></definition>
</function>

<function name="log_in"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the authenticated user has never begun a session.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="boolean" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	INSERT INTO
		user_activity (user_id, timestamp, terminal_id, type, detail)
		SELECT _uid, current_timestamp, terminal_validate (_remote_addr), 'login', NULL;

	PERFORM 1 FROM account WHERE user_id = _uid AND is_first = TRUE;
	RETURN FOUND;
END;]]></definition>
</function>

<function name="this_terminal_info_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get credentials and general info on the terminal from where the user connects.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<parameter name="terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="term_type">
		<type name="av.terminal_type" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="qz_private_key">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="qz_certificate">
		<type name="text" length="0"/>
	</parameter>
	<parameter name="shift_user">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[SELECT terminal_id, term_type, name, qz_private_key, qz_certificate, login
	FROM terminal 
		NATURAL LEFT JOIN 
			(SELECT * FROM cashier_shift WHERE shift_end IS NULL) AS q
		NATURAL LEFT JOIN account
	WHERE ip_addr = _remote_addr;]]></definition>
</function>

<function name="log_out"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the authenticated user has never begun a session.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[INSERT INTO
	user_activity (user_id, timestamp, terminal_id, type, detail)
	SELECT _uid, current_timestamp, terminal_validate (_remote_addr), 'logout', NULL;]]></definition>
</function>

<function name="terminal_validate"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Return terminal_id given the remote address. Raise exception if not found (connecting from unauthorized IP).]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="smallint" length="0"/>
	</return-type>
	<parameter name="_remote_addr">
		<type name="inet" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
BEGIN
	SELECT terminal_id INTO _terminal_id FROM terminal WHERE ip_addr = _remote_addr;
	IF NOT FOUND THEN 
		PERFORM charp_raise ('ASSERT', _remote_addr::text || ' not registered.');
	END IF;
	RETURN _terminal_id;
END;]]></definition>
</function>

<function name="anon_supervisor_create"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Create a supervisor user IF there are no supervisors already. For activatioin only.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_password">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_new_user_id av.account.user_id%TYPE;
BEGIN
	IF rp.anon_system_is_activated() IS NULL OR rp.anon_supervisor_created() THEN
		PERFORM charp_raise ('USERPERM');
	END IF;

	_new_user_id := user_create (1::uid, _login, _password, NULL);
	PERFORM user_role_add (_new_user_id, 'supervisor');
END;]]></definition>
</function>

<function name="anon_user_password_change"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Change a user's password using a one-time support challenge.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_login">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_plain_password">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_chal">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_solution">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_user_id av.account.user_id%TYPE;
BEGIN
	PERFORM 1 FROM supervisor_challenge WHERE string = _chal AND user_id = 1::uid;
	IF NOT FOUND THEN PERFORM charp_raise ('USERPERM'); END IF;

	-- one-time challenge. Discard.
	DELETE FROM supervisor_challenge WHERE string = _chal;

	IF _solution IS NULL OR _solution <> activation_solve_challenge (_chal) THEN
		PERFORM charp_raise ('EXIT', 'BAD_SOLUTION');
	END IF;	

	_user_id := charp_account_get_id_by_login_status (_login, 'active');

	PERFORM av.user_password_change (_user_id, _plain_password);
END;]]></definition>
</function>

<function name="user_supervisor_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that the given uid is from a supervisor. If not, raise exception.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM 1 FROM user_supervisor WHERE user_id = _user_id;
	IF NOT FOUND THEN PERFORM charp_raise('USERPERM'); END IF;
END;]]></definition>
</function>

<function name="cashier_shift_begin"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Register a shift in cashier_shift and a deposit ticket/payment for the amount provided.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_deposit_amount">
		<type name="integer" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_shift_id av.cashier_shift.shift_id%TYPE;
	_ticket_id av.ticket.ticket_id%TYPE;
BEGIN
	PERFORM user_cashier_assert(_uid);
	_terminal_id := terminal_validate(_remote_addr);

	PERFORM 1 FROM cashier_shift 
		WHERE shift_end IS NULL AND (terminal_id = _terminal_id OR user_id = _uid);
	IF FOUND THEN PERFORM charp_raise ('DATADUP'); END IF;

	INSERT INTO
		cashier_shift (shift_id, terminal_id, user_id, consecutive,
			last_event, shift_start, shift_end)
		VALUES (DEFAULT, _terminal_id, _uid, av.terminal_shift_consecutive_next(_terminal_id),
			CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL)
		RETURNING shift_id INTO _shift_id;

	INSERT INTO
		user_activity (user_id, timestamp, terminal_id, type, 
			detail)
		VALUES (_uid, CURRENT_TIMESTAMP, _terminal_id, 'shift_begin',
			json_build_object ('shift_id', _shift_id));

	INSERT INTO
		ticket (ticket_id, shift_id, timestamp, type, detail)
		VALUES (DEFAULT, _shift_id, CURRENT_TIMESTAMP, 'deposit', NULL)
		RETURNING ticket_id INTO _ticket_id;

	INSERT INTO
		movement (ticket_id, timestamp, rate_id, method, amount, change, reference)
		VALUES (_ticket_id, CURRENT_TIMESTAMP, NULL, 'tender', _deposit_amount, NULL, NULL);
END;]]></definition>
</function>

<function name="user_cashier_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Check that the given uid is from a cashier. If not, raise exception.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM 1 FROM user_cashier WHERE user_id = _user_id;
	IF NOT FOUND THEN PERFORM charp_raise('USERPERM'); END IF;
END;]]></definition>
</function>

<function name="cashier_park_charge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Registers the charge of temporary parking.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_ticket_terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="_entry_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_charge_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_ticket_type">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_rate_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_method">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="_amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_reference">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_shift_id av.cashier_shift.shift_id%TYPE;
	_terminal_id av.terminal.terminal_id%TYPE;
	_ticket_id ticket.ticket_id%TYPE;
	_last_event av.ts;
	_rate_id av.rate.rate_id%TYPE;
	_type av.ticket_type;
	_ticket_detail av.ticket.detail%TYPE;
BEGIN
	SELECT shift_id, terminal_id INTO _shift_id, _terminal_id
		FROM cashier_shift_assert (_uid, _remote_addr);

	_last_event := cashier_shift_update_last_event (_uid, _terminal_id);
	IF _charge_ts < _last_event THEN 
		PERFORM charp_raise ('USERPERM', 'last_event'); -- exception will roll back previous update
	END IF;

	_type = _ticket_type::av.ticket_type;
	IF _type <> 'entry' AND _type <> 'deposit' AND _type <> 'lost' THEN 
		PERFORM charp_raise ('ASSERT', 'Ticket type ' || _ticket_type || ' not supported');
	END IF;

	_ticket_detail := NULL;
	IF _ticket_terminal_id <> _terminal_id THEN
		_ticket_detail := json_build_object ('terminal_id', _ticket_terminal_id);
	END IF;

	IF _ticket_type <> 'entry' OR _ticket_terminal_id <> _terminal_id THEN
		INSERT INTO
			ticket (ticket_id, shift_id, timestamp, type, detail)
			VALUES (DEFAULT, _shift_id, _entry_ts, _type, _ticket_detail)
			RETURNING ticket_id INTO _ticket_id;
	ELSE
		SELECT ticket_id INTO _ticket_id FROM ticket NATURAL JOIN cashier_shift
			WHERE terminal_id = _terminal_id
				AND date_trunc ('second', timestamp) = _entry_ts
				AND type = _type;
		IF NOT FOUND THEN PERFORM charp_raise ('NOTFOUND'); END IF;
	END IF;

	INSERT INTO
		movement (ticket_id, timestamp, rate_id, method, amount, change, reference)
		SELECT _ticket_id, _charge_ts, rate_id, _method::av.payment_type, _amount, _change, _reference
			FROM rate WHERE rate.name = _rate_name AND (rate.type = 'regular' OR rate.type = 'lost')
        RETURNING rate_id INTO _rate_id;

	IF _rate_id IS NULL THEN PERFORM charp_raise ('ASSERT', 'Rate "' || _rate_name || '" not found'); END IF;
END;]]></definition>
</function>

<function name="cashier_shift_assert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[In one query, check that the user is a cashier and the remote address is of a terminal where the user has a shift begun. Return terminal_id.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="shift_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_user_id">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_shift_id av.cashier_shift.shift_id%TYPE;
	_terminal_id av.terminal.terminal_id%TYPE;
BEGIN
	SELECT s.shift_id, s.terminal_id INTO _shift_id, _terminal_id
		FROM cashier_shift AS s NATURAL JOIN terminal
		WHERE ip_addr = _remote_addr AND user_id = _user_id AND shift_end IS NULL;

	IF NOT FOUND THEN PERFORM charp_raise ('USERPERM', 'shift'); END IF;

	shift_id := _shift_id;
	terminal_id := _terminal_id;

	RETURN NEXT;
END;]]></definition>
</function>

<function name="cashier_shift_update_last_event"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Update the last_event field with NOW. Assumes the cashier shift has already been validated.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</return-type>
	<parameter name="_user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="_terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_last_event av.ts;
BEGIN
	SELECT last_event INTO _last_event FROM cashier_shift
		WHERE terminal_id = _terminal_id AND user_id = _user_id AND shift_end IS NULL;

	UPDATE cashier_shift SET last_event = CURRENT_TIMESTAMP 
		WHERE terminal_id = _terminal_id AND user_id = _user_id AND shift_end IS NULL;

	RETURN _last_event;
END;]]></definition>
</function>

<function name="cashier_park_charge_check"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the ticket exists and has not been already charged. Register the user's intention to charge.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_ticket_terminal_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="_ticket_entry_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_ticket_id av.ticket.ticket_id%TYPE;
	_movement_ts av.movement.timestamp%TYPE;
BEGIN
	SELECT terminal_id INTO _terminal_id
		FROM cashier_shift_assert (_uid, _remote_addr);

	PERFORM 1 FROM (
		WITH t AS 
			( SELECT ticket_id, detail FROM ticket
				WHERE date_trunc ('second', timestamp) = _ticket_entry_ts )
		SELECT 1 
			FROM t NATURAL JOIN cashier_shift	JOIN movement USING (ticket_id)
			WHERE _ticket_terminal_id = terminal_id
				OR _ticket_terminal_id = (t.detail->>'terminal_id')::integer
	) AS x;

	IF FOUND THEN PERFORM charp_raise ('DATADUP'); END IF;

	INSERT INTO 
		user_activity (user_id, timestamp, terminal_id, type, 
			detail)
		VALUES (_uid, CURRENT_TIMESTAMP, _terminal_id, 'charge_check', 
			jsonb_build_object ('terminal_id', _ticket_terminal_id, 'timestamp', _ticket_entry_ts));
END;]]></definition>
</function>

<index name="rate_uq" table="av.rate"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[Rates are unique by name.]]></comment>
		<idxelement use-sorting="false">
			<column name="name"/>
		</idxelement>
</index>

<function name="cashier_shift_end"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Remove corresponding cashier_shift and return accounting for the shift.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="terminal_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_terminal_id av.terminal.terminal_id%TYPE;
	_start timestamp with time zone;
	_type av.user_activity.type%TYPE;
BEGIN
	SELECT terminal_id INTO _terminal_id
		FROM cashier_shift_assert (_uid, _remote_addr);

	SELECT ua.timestamp, type INTO _start, _type FROM user_activity AS ua
		WHERE user_id = _uid AND (type = 'shift_begin' OR type = 'shift_end')
		ORDER BY timestamp DESC LIMIT 1;

	-- No shifts ever begun (so no last shift), or last shift has already been ended.
	IF NOT FOUND OR _type = 'shift_end' THEN PERFORM charp_raise ('NOTFOUND'); END IF;

	INSERT INTO 
		user_activity (user_id, timestamp, terminal_id, type, detail)
		VALUES (_uid, CURRENT_TIMESTAMP, _terminal_id, 'shift_end', NULL);

	UPDATE cashier_shift SET shift_end = CURRENT_TIMESTAMP 
		WHERE terminal_id = _terminal_id AND user_id = _uid AND shift_end IS NULL;

	IF NOT FOUND THEN PERFORM charp_raise ('NOTFOUND'); END IF;

	RETURN QUERY
		SELECT r.terminal_name, r.concept, r.rate, r.amount, r.change, r.timestamp
			FROM av.cashier_shift_report (_uid, _start, NULL) AS r;

	-- Provide the shift number by counting the number of shifts for the user.
	RETURN QUERY
		SELECT ''::varchar, 'shift_end'::varchar, NULL::varchar, COUNT(*)::integer, 0, CURRENT_TIMESTAMP
			FROM user_activity WHERE user_id = _uid AND type = 'shift_begin';
END;]]></definition>
</function>

<function name="cashier_park_entry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Registers the entry of a vehicle for temporary parking.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_entry_ts">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_shift_id av.cashier_shift.shift_id%TYPE;
	_terminal_id av.terminal.terminal_id%TYPE;
	_consecutive av.terminal.entry_consecutive%TYPE;
	_last_event av.ts;
BEGIN
	SELECT shift_id, terminal_id INTO _shift_id, _terminal_id
		FROM cashier_shift_assert (_uid, _remote_addr);

	_last_event := cashier_shift_update_last_event (_uid, _terminal_id);
	IF _entry_ts < _last_event THEN 
		PERFORM charp_raise ('USERPERM'); -- exception will rollback previous update
	END IF;

	UPDATE terminal SET entry_consecutive = entry_consecutive + 1
		WHERE terminal_id = _terminal_id
		RETURNING entry_consecutive INTO _consecutive;

	INSERT INTO 
		ticket (ticket_id, shift_id, timestamp, type, 
			detail)
		VALUES (DEFAULT, _shift_id, _entry_ts, 'entry', 
			json_build_object ('consecutive', _consecutive));

	RETURN _consecutive;
END;]]></definition>
</function>

<function name="supervisor_shift_summary_report"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get a report of activities for the given parameters.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="_start">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_end">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_users">
		<type name="smallint" length="0" dimension="1"/>
	</parameter>
	<parameter name="_shifts">
		<type name="integer" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert(_uid);

	IF _start IS NULL THEN
		_start := '2017-01-01 00:00:00'::timestamptz;
	END IF;

	IF _end IS NULL THEN
		_end := CURRENT_TIMESTAMP;
	END IF;

	RETURN QUERY
		SELECT 'shift_begin'::varchar, movement.amount, 0, ua.timestamp,
			FROM user_activity AS ua 
				NATURAL JOIN cashier_shift
				JOIN ticket USING (shift_id)
				JOIN movement USING (ticket_id)
			WHERE terminal_id = _terminal_id 
				AND ua.type = 'shift_begin';

	RETURN QUERY
		SELECT * FROM cashier_shift_report (

	RETURN QUERY
		SELECT 'shift_end'::varchar, 0, 0, 
			ua.timestamp::timestamp with time zone, 
			ua.timestamp::timestamp with time zone
			FROM user_activity AS ua 
			WHERE ua.terminal_id = _terminal_id 
				AND ua.type = 'shift_end' AND ua.timestamp > _start;
END;]]></definition>
</function>

<function name="rate_get_script"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get active regular rates for the rate selection screen.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="text" length="0"/>
	</return-type>
	<parameter name="_name">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_script text;
BEGIN
	SELECT r.script INTO STRICT _script FROM rate AS r
		WHERE is_active = TRUE AND r.name = _name;

	RETURN _script;
END;]]></definition>
</function>

<function name="cashier_park_get_rates"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get active rates for the rate selection screen.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="label">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="label_client">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_remote_addr">
		<type name="av.remote_addr" length="0"/>
	</parameter>
	<parameter name="_type">
		<type name="varchar" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM cashier_shift_assert (_uid, _remote_addr);

	RETURN QUERY 
		SELECT r.name, r.label, r.label_client FROM rate AS r
			WHERE type = _type::av.rate_type AND is_active = TRUE
			ORDER BY position;
END;]]></definition>
</function>

<function name="cashier_shift_report"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Return accounting for the shift starting at _start for the given user.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="terminal_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="shift_id">
		<type name="integer" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_user_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="_start">
		<type name="av.ts" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_end">
		<type name="av.ts" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	IF _end IS NULL THEN
		SELECT ua.timestamp INTO _end FROM user_activity AS ua
			WHERE type = 'shift_end' AND ua.timestamp > _start
				AND (_user_id IS NULL OR ua.user_id = _user_id)
			ORDER BY timestamp LIMIT 1;

		IF NOT FOUND THEN _end = CURRENT_TIMESTAMP; END IF;
	END IF;

	RETURN QUERY
		SELECT term.name, ua.type::varchar, NULL::varchar, movement.amount, s.shift_id, _start::timestamptz, s.user_id, s.shift_id
			FROM user_activity AS ua
				NATURAL JOIN terminal AS term 
				NATURAL JOIN cashier_shift AS s
				JOIN ticket USING (shift_id, timestamp)
				JOIN movement USING (ticket_id)
			WHERE ua.type = 'shift_begin' AND ua.timestamp >= _start
				AND (_user_id IS NULL OR s.user_id = _user_id);

	RETURN QUERY
		SELECT term.name, t.type::varchar, r.name, m.amount, m.change, m.timestamp::timestamptz, s.user_id, s.shift_id
			FROM ticket AS t 
				NATURAL JOIN cashier_shift AS s
				NATURAL JOIN terminal AS term
				LEFT JOIN movement AS m USING (ticket_id)
				LEFT JOIN rate AS r USING (rate_id)
			WHERE ((m.timestamp IS NULL AND _start < t.timestamp) OR (_start < m.timestamp AND m.timestamp <= _end))
				AND (_user_id IS NULL OR s.user_id = _user_id);
END;]]></definition>
</function>

<function name="cashier_shift_report"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Show current balance for the running shift.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="terminal_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[DECLARE
	_start timestamp with time zone;
BEGIN
	SELECT ua.timestamp, type INTO _start FROM user_activity AS ua
		WHERE user_id = _uid AND type = 'shift_begin'
		ORDER BY timestamp DESC LIMIT 1;

	IF NOT FOUND THEN PERFORM charp_raise ('NOTFOUND'); END IF;

	RETURN QUERY
		SELECT r.terminal_name, r.concept, r.rate, r.amount, r.change, r.timestamp
			FROM av.cashier_shift_report (_uid, _start, NULL) AS r;

	-- Provide the shift number by counting the number of shifts for the user.
	RETURN QUERY
		SELECT ''::varchar, 'shift_end'::varchar, NULL::varchar, COUNT(*)::integer, 0, CURRENT_TIMESTAMP
			FROM user_activity WHERE user_id = _uid AND type = 'shift_begin';
END;]]></definition>
</function>

<index name="cashier_shift_start_end_idx" table="av.cashier_shift"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="false" asc-order="false">
			<column name="shift_start"/>
		</idxelement>
		<idxelement use-sorting="true" nulls-first="true" asc-order="false">
			<column name="shift_end"/>
		</idxelement>
</index>

<index name="cashier_shift_end_idx" table="av.cashier_shift"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="true" nulls-first="true" asc-order="false">
			<column name="shift_end"/>
		</idxelement>
</index>

<relationship name="user_cashier_has_many_cashier_shift" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.user_cashier"
	 dst-table="av.cashier_shift"
	 src-required="false" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<relationship name="terminal_has_many_cashier_shift" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#aa0000"
	 src-table="av.terminal"
	 dst-table="av.cashier_shift"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<index name="cashier_shift_end_unique_null" table="av.cashier_shift"
	 concurrent="false" unique="true" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
	<comment><![CDATA[An user can only have one acitve (NULL end) shift.]]></comment>
		<idxelement use-sorting="false">
			<column name="user_id"/>
		</idxelement>
	<predicate><![CDATA[shift_end IS NULL]]></predicate>
</index>

<function name="anon_rates_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get user-visible (not fragments nor system), active rates ]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<parameter name="name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="type">
		<type name="av.rate_type" length="0"/>
	</parameter>
	<parameter name="label">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="label_client">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<definition><![CDATA[SELECT r.name, r.type, r.label, r.label_client FROM av.rate AS r 
	WHERE r.type <> 'system' AND r.type <> 'fragment' AND r.is_active
	ORDER BY r.position;]]></definition>
</function>

<relationship name="cashier_shift_has_many_ticket" type="rel1n"
	 src-col-pattern="{sc}"
	 pk-pattern="{dt}_pk" uq-pattern="{dt}_uq"
	 src-fk-pattern="{st}_fk"
	 custom-color="#83af1f"
	 src-table="av.cashier_shift"
	 dst-table="av.ticket"
	 src-required="true" dst-required="false"
	 deferrable="true" defer-type="INITIALLY DEFERRED"/>

<index name="ticket_timestamp_idx" table="av.ticket"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="0">
		<idxelement use-sorting="false">
			<column name="&quot;timestamp&quot;"/>
		</idxelement>
</index>

<function name="supervisor_get_shifts"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get a report of activities for the given parameters.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="shift_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="terminal_name">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="cashier">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="start">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="end">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_start">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_end">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert(_uid);

	IF _start IS NULL THEN
		_start := '2017-01-01 00:00:00'::timestamptz;
	END IF;

	IF _end IS NULL THEN
		_end := CURRENT_TIMESTAMP;
	END IF;

	RETURN QUERY
		SELECT cs.shift_id, t.name, a.login, 
			cs.shift_start::timestamptz, cs.shift_end::timestamptz
			FROM cashier_shift AS cs
				NATURAL JOIN account AS a NATURAL JOIN terminal AS t
			WHERE (_end IS NULL OR shift_start < _end)
				AND (_start IS NULL 
					OR shift_end IS NULL OR shift_end >= _start);
END;]]></definition>
</function>

<function name="supervisor_summary_report"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get a report of activities for the given parameters.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="shift_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="cashier">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="ticket_timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_start">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_end">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_shifts">
		<type name="integer" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert(_uid);

	IF _start IS NULL THEN
		_start := '2017-01-01 00:00:00'::timestamptz;
	END IF;

	IF _end IS NULL THEN
		_end := CURRENT_TIMESTAMP;
	END IF;

	IF array_length (_shifts, 1) = 0 THEN
		_shifts = NULL;
	END IF;

	RETURN QUERY
		SELECT * FROM operations_get (_start, _end, _shifts) 
			ORDER BY timestamp, concept;
END;]]></definition>
</function>

<function name="operations_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Get a report of activities for the given parameters.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="shift_id">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="cashier">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="concept">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="rate">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="amount">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="change">
		<type name="integer" length="0"/>
	</parameter>
	<parameter name="timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="ticket_timestamp">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	</return-type>
	<parameter name="_start">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_end">
		<type name="timestamp with time zone" length="0" with-timezone="true"/>
	</parameter>
	<parameter name="_shifts">
		<type name="integer" length="0" dimension="1"/>
	</parameter>
	<definition><![CDATA[BEGIN
	-- shift_begin and shift_end events.
	RETURN QUERY
		WITH sop AS
			( SELECT cs.shift_id, cs.terminal_id, cs.user_id,
				ua.type::varchar AS concept, 
				movement.amount AS amount, 
				ua.timestamp AS timestamp
				FROM cashier_shift AS cs
					JOIN user_activity AS ua 
						ON (shift_start = ua.timestamp OR
							shift_end = ua.timestamp)
					LEFT JOIN ticket USING (timestamp)
					LEFT JOIN movement USING (ticket_id)
				WHERE _start <= ua.timestamp AND ua.timestamp < _end
					AND (_shifts IS NULL OR cs.shift_id = ANY (_shifts))
			)
			SELECT sop.shift_id, sop.terminal_id, account.login,
				sop.concept, NULL::varchar, sop.amount, 0, 
				sop.timestamp::timestamptz, NULL::timestamptz
				FROM sop 
					NATURAL JOIN account;

	-- Tickets with associated movements. (entries mostly)
	RETURN QUERY
		SELECT cs.shift_id, cs.terminal_id, account.login,
			t.type::varchar, NULL::varchar, NULL::integer, NULL::integer, 
			t.timestamp::timestamptz, t.timestamp::timestamptz
			FROM ticket AS t
				NATURAL JOIN cashier_shift AS cs
				NATURAL JOIN account
				JOIN movement USING (ticket_id)
			WHERE t.type = 'entry'
				AND (_start <= t.timestamp AND t.timestamp < _end)
				AND (_shifts IS NULL OR cs.shift_id = ANY (_shifts));

	-- All other operations.
	RETURN QUERY
		SELECT cs.shift_id, cs.terminal_id, account.login, 
			CASE WHEN t.type = 'entry' AND m.timestamp IS NOT NULL
				THEN 'exit'::varchar 
				ELSE t.type::varchar
			END,
			r.name, m.amount, m.change,			
			COALESCE(m.timestamp, t.timestamp)::timestamptz, t.timestamp::timestamptz
			FROM ticket AS t 
				NATURAL JOIN cashier_shift AS cs
				NATURAL JOIN account
				LEFT JOIN movement AS m USING (ticket_id)
				LEFT JOIN rate AS r USING (rate_id)
			WHERE ((m.timestamp IS NULL AND _start <= t.timestamp) 
					OR (_start <= m.timestamp AND m.timestamp < _end))
				AND (_shifts IS NULL OR cs.shift_id = ANY (_shifts));
END;]]></definition>
</function>

<function name="terminal_shift_consecutive_next"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="av"/>
	<role name="postgres"/>
	<comment><![CDATA[Increment the shift consecutive for the given terminal, returning the new value.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="integer" length="0"/>
	</return-type>
	<parameter name="_terminal_id">
		<type name="smallint" length="0"/>
	</parameter>
	<definition><![CDATA[UPDATE terminal SET shift_consecutive = shift_consecutive + 1
	WHERE terminal_id = _terminal_id
	RETURNING shift_consecutive;
]]></definition>
</function>

<function name="log_remove_first"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Check if the authenticated user has never begun a session.]]></comment>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[UPDATE account SET is_first = FALSE WHERE user_id = _uid;
]]></definition>
</function>

<function name="all_terminals_info_get"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get basic information on the terminals in the system for supervisors.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="type">
		<type name="varchar" length="0"/>
	</parameter>
	<parameter name="name">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert (_uid);

	RETURN QUERY
		SELECT t.terminal_id, t.term_type::varchar, t.name FROM terminal AS t;
END;]]></definition>
</function>

<function name="supervisor_save_file_to_usb"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Copy the given file to USB mass storage device.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void" length="0"/>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<parameter name="_filename">
		<type name="varchar" length="0" with-timezone="true"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert(_uid);
	PERFORM charp_cmd ('OTHER', 'File-CopyToUsb', _filename);
END;]]></definition>
</function>

<function name="supervisor_get_users"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="rp"/>
	<role name="postgres"/>
	<comment><![CDATA[Get a login/id list of the available users on the system.]]></comment>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<parameter name="id">
		<type name="smallint" length="0"/>
	</parameter>
	<parameter name="login">
		<type name="varchar" length="0"/>
	</parameter>
	</return-type>
	<parameter name="_uid">
		<type name="av.uid" length="0"/>
	</parameter>
	<definition><![CDATA[BEGIN
	PERFORM user_supervisor_assert(_uid);

	RETURN QUERY
		SELECT a.user_id, a.login 
			FROM account AS a 
			WHERE status = 'active' AND a.user_id > 1;
END;]]></definition>
</function>

<constraint name="account_creator_fk" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="av.account" table="av.account">
	<columns names="creator_user_id" ref-type="src-columns"/>
	<columns names="user_id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_account_account" type="relfk"
	 src-table="av.account"
	 dst-table="av.account" reference-fk="account_creator_fk"
	 src-required="false" dst-required="false">
	<line>
		<position x="429.716" y="1229.85"/>
	<position x="429.716" y="1169"/>
	<position x="292.477" y="1169"/>
	</line>
	<label ref-type="dst-label">
		<position x="-5.86667" y="1.8"/>
	</label>
</relationship>

<permission>
	<object name="avanty" type="database"/>
	<roles names="avanty"/>
	<privileges connect="true"/>
</permission>
<permission>
	<object name="pgcrypto" type="schema"/>
	<roles names="avanty"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="av.request" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.account" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="rp" type="schema"/>
	<roles names="avanty"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="av.request_log" type="table"/>
	<roles names="avanty"/>
	<privileges insert="true"/>
</permission>
<permission>
	<object name="av.user_supervisor" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.user_cashier" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.user_maintenance" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true"/>
</permission>
<permission>
	<object name="av.terminal" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" update="true"/>
</permission>
<permission>
	<object name="av.ticket" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.cashier_shift" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="av.user_activity" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.supervisor_challenge" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="av.movement" type="table"/>
	<roles names="avanty"/>
	<privileges select="true" insert="true"/>
</permission>
<permission>
	<object name="av.rate" type="table"/>
	<roles names="avanty"/>
	<privileges select="true"/>
</permission>
</dbmodel>
